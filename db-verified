"constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}"
"constructor(address[] memory tokensToList, uint256 mintAmount, string memory name_, string memory symbol_) ERC20(name_, symbol_) {\n  // Basic exchange configuration\n  Config memory config;\n  config.unlocked = false;\n  config.oneMinusTradingFee = 0xffbe76c8b4395800;   // approximately 0.999\n  config.delistingBonus = 0;\n  DFPconfig = config;\n\n  // Configure the listed tokens as such\n  TokenSettings memory listed;\n  listed.state = State.Listed;\n  require(tokensToList.length == 15, ""Incorrect number of tokens"");\n  address previous = address(0);\n  address current = address(0);\n  for (uint256 i = 0; i < 15; i++) {\n    current = tokensToList[i];\n    require(current > previous, ""Require ordered list"");\n    listedTokens[current] = listed;\n    previous = current;\n  }\n\n  // Generate the LP tokens reflecting the initial liquidity (to be loaded externally)\n  _mint(msg.sender, mintAmount);\n}"
receive() external payable {}
"function swap(\n  address inputToken,\n  address outputToken,\n  uint256 inputAmount,\n  uint256 minOutputAmount\n)\n  external\n  payable\n  onlyListedToken(inputToken)\n  onlyListedToken(outputToken)\n  override\n  returns (uint256 outputAmount)\n{\n  // Check that the exchange is unlocked and thus open for business\n  Config memory _config = DFPconfig;\n  require(_config.unlocked, ""DFP: Locked"");\n\n  // Pull in input token and check the exchange balance for that token\n  uint256 initialInputBalance;\n  if (inputToken == address(0)) {\n    require(msg.value == inputAmount, ""DFP: bad ETH amount"");\n    initialInputBalance = address(this).balance - inputAmount;\n  } else {\n    initialInputBalance = IERC20(inputToken).balanceOf(address(this));\n    IERC20(inputToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n  }\n\n  // Check dex balance of the output token\n  uint256 initialOutputBalance;\n  if (outputToken == address(0)) {\n    initialOutputBalance = address(this).balance;\n  } else {\n    initialOutputBalance = IERC20(outputToken).balanceOf(address(this));\n  }\n\n  // Calculate the output amount through the x*y=k invariant\n  // Can skip overflow/underflow checks on this calculation as they will always work against an attacker anyway.\n  uint256 netInputAmount = inputAmount * _config.oneMinusTradingFee;\n  outputAmount = netInputAmount * initialOutputBalance / ((initialInputBalance << 64) + netInputAmount);\n  require(outputAmount > minOutputAmount, ""DFP: No deal"");\n\n  // Send output tokens to whoever invoked the swap function\n  if (outputToken == address(0)) {\n    address payable sender = payable(msg.sender);\n    sender.transfer(outputAmount);\n  } else {\n    IERC20(outputToken).safeTransfer(msg.sender, outputAmount);\n  }\n\n  // Emit swap event to enable better governance decision making\n  emit Swapped(msg.sender, inputToken, outputToken, inputAmount, outputAmount);\n}"
"function addLiquidity(address inputToken, uint256 inputAmount, uint256 minLP)\n    external\n    payable\n    onlyListedToken(inputToken)\n    override\n    returns (uint256 actualLP)\n  {\n    // Check that the exchange is unlocked and thus open for business\n    Config memory _config = DFPconfig;\n    require(_config.unlocked, ""DFP: Locked"");\n\n    // Pull in input token and check the exchange balance for that token\n    uint256 initialBalance;\n    if (inputToken == address(0)) {\n      require(msg.value == inputAmount, ""DFP: Incorrect amount of ETH"");\n      initialBalance = address(this).balance - inputAmount;\n    } else {\n      initialBalance = IERC20(inputToken).balanceOf(address(this));\n      IERC20(inputToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n    }\n\n    // Prevent excessive liquidity add which runs of the approximation curve\n    require(inputAmount < initialBalance, ""DFP: Too much at once"");\n\n    // See https://en.wikipedia.org/wiki/Binomial_approximation for the below\n    // Compute the 6th power binomial series approximation of R.\n    //\n    //                   X   15 X^2   155 X^3   7285 X^4   91791 X^5   2417163 X^6\n    // (1+X)^1/16 - 1 â‰ˆ -- - ------ + ------- - -------- + --------- - -----------\n    //                  16    512      8192      524288     8388608     268435456\n    //\n    // Note that we need to terminate at an even order to guarantee an underestimate\n    // for safety. The underestimation leads to slippage for higher amounts, but\n    // protects funds of those that are already invested.\n    uint256 X = (inputAmount * _config.oneMinusTradingFee) / initialBalance;  // 0.64 bits\n    uint256 X_ = X * X;                                // X^2   0.128 bits\n    uint256 R_ = (X >> 4) - (X_ * 15 >> 73);           // R2    0.64 bits\n    X_ = X_ * X;                                       // X^3   0.192 bits\n    R_ = R_ + (X_ * 155 >> 141);                       // R3    0.64 bits\n    X_ = X_ * X >> 192;                                // X^4   0.64 bits\n    R_ = R_ - (X_ * 7285 >> 19);                       // R4    0.64 bits\n    X_ = X_ * X;                                       // X^5   0.128 bits\n    R_ = R_ + (X_ * 91791 >> 87);                      // R5    0.64 bits\n    X_ = X_ * X;                                       // X^6   0.192 bits\n    R_ = R_ - (X_ * 2417163 >> 156);                   // R6    0.64 bits\n\n    // Calculate and mint LPs to be awarded\n    actualLP = R_ * totalSupply() >> 64;\n    require(actualLP > minLP, ""DFP: No deal"");\n    _mint(msg.sender, actualLP);\n\n    // Emitting liquidity add event to enable better governance decisions\n    emit LiquidityAdded(msg.sender, inputToken, inputAmount, actualLP);\n  }\n\n"
"function addMultiple(address[] calldata tokens, uint256[] calldata maxAmounts)\n  external\n  payable\n  override\n  returns (uint256 actualLP)\n{\n  // Perform basic checks\n  Config memory _config = DFPconfig;\n  require(_config.unlocked, ""DFP: Locked"");\n  require(tokens.length == 16, ""DFP: Bad tokens array length"");\n  require(maxAmounts.length == 16, ""DFP: Bad maxAmount array length"");\n\n  // Check ETH amount/ratio first\n  require(tokens[0] == address(0), ""DFP: No ETH found"");\n  require(maxAmounts[0] == msg.value, ""DFP: Incorrect ETH amount"");\n  uint256 dexBalance = address(this).balance - msg.value;\n  uint256 actualRatio = msg.value * (1<<128) / dexBalance;\n\n  // Check ERC20 amounts/ratios\n  uint256 currentRatio;\n  address previous;\n  address token;\n  for (uint256 i = 1; i < 16; i++) {\n    token = tokens[i];\n    require(token > previous, ""DFP: Require ordered list"");\n    require(\n      listedTokens[token].state > State.Delisting,\n      ""DFP: Token not listed""\n    );\n    dexBalance = IERC20(token).balanceOf(address(this));\n    currentRatio = maxAmounts[i] * (1 << 128) / dexBalance;\n    if (currentRatio < actualRatio) {\n      actualRatio = currentRatio;\n    }\n    previous = token;\n  }\n\n  // Calculate how many LP will be generated\n  actualLP = (actualRatio * totalSupply() >> 64) * DFPconfig.oneMinusTradingFee >> 128;\n\n  // Collect ERC20 tokens\n  for (uint256 i = 1; i < 16; i++) {\n    token = tokens[i];\n    dexBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransferFrom(msg.sender, address(this), dexBalance * actualRatio >> 128);\n  }\n\n  // Mint the LP tokens\n  _mint(msg.sender, actualLP);\n  emit MultiLiquidityAdded(msg.sender, actualLP, totalSupply());\n\n  // Refund ETH change\n  dexBalance = address(this).balance - msg.value;\n  address payable sender = payable(msg.sender);\n  sender.transfer(msg.value - (dexBalance * actualRatio >> 128));\n}"
"function removeLiquidity(uint256 LPamount, address outputToken, uint256 minOutputAmount)\n  external\n  onlyListedToken(outputToken)\n  override\n  returns (uint256 actualOutput)\n{\n  // Checks the initial balance of the token desired as output token\n  uint256 initialBalance;\n  if (outputToken == address(0)) {\n    initialBalance = address(this).balance;\n  } else {\n    initialBalance = IERC20(outputToken).balanceOf(address(this));\n  }\n\n  // Calculates intermediate variable F = (1-R)^16 and then the resulting output amount.\n  uint256 F_;\n  F_ = (1 << 64) - (LPamount << 64) / totalSupply();   // (1-R)      (0.64 bits)\n  F_ = F_ * F_;                                       // (1-R)^2    (0.128 bits)\n  F_ = F_ * F_ >> 192;                                // (1-R)^4    (0.64 bits)\n  F_ = F_ * F_;                                       // (1-R)^8    (0.128 bits)\n  F_ = F_ * F_ >> 192;                                // (1-R)^16   (0.64 bits)\n  actualOutput = initialBalance * ((1 << 64) - F_) >> 64;\n  require(actualOutput > minOutputAmount, ""DFP: No deal"");\n\n  // Burns the LP tokens and sends the output tokens\n  _burn(msg.sender, LPamount);\n  if (outputToken == address(0)) {\n    address payable sender = payable(msg.sender);\n    sender.transfer(actualOutput);\n  } else {\n    IERC20(outputToken).safeTransfer(msg.sender, actualOutput);\n  }\n\n  // Emitting liquidity removal event to enable better governance decisions\n  emit LiquidityRemoved(msg.sender, outputToken, actualOutput, LPamount);\n}"
"function removeMultiple(uint256 LPamount, address[] calldata tokens)\n  external\n  override\n  returns (bool success)\n{\n  // Perform basic validation (no lock check here on purpose)\n  require(tokens.length == 16, ""DFP: Bad tokens array length"");\n\n  // Calculate fraction of total liquidity to be returned\n  uint256 fraction = (LPamount << 128) / totalSupply();\n\n  // Send the ETH first (use transfer to prevent reentrancy)\n  uint256 dexBalance = address(this).balance;\n  address payable sender = payable(msg.sender);\n  sender.transfer(fraction * dexBalance >> 128);\n\n  // Send the ERC20 tokens\n  address previous;\n  for (uint256 i = 1; i < 16; i++) {\n    address token = tokens[i];\n    require(token > previous, ""DFP: Require ordered list"");\n    require(\n      listedTokens[token].state > State.Delisting,\n      ""DFP: Token not listed""\n    );\n    dexBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(msg.sender, fraction * dexBalance >> 128);\n    previous = token;\n  }\n\n  // Burn the LPs\n  _burn(msg.sender, LPamount);\n  emit MultiLiquidityRemoved(msg.sender, LPamount, totalSupply());\n\n  // That's all folks\n  return true;\n}"
"function bootstrapNewToken(\n  address inputToken,\n  uint256 maxInputAmount,\n  address outputToken\n) public override returns (uint64 fractionBootstrapped) {\n  // Check whether the valid token is being bootstrapped\n  TokenSettings memory tokenToList = listedTokens[inputToken];\n  require(\n    tokenToList.state == State.PreListing,\n    ""DFP: Wrong token""\n  );\n\n  // Calculate how many tokens to actually take in (clamp at max available)\n  uint256 initialInputBalance = IERC20(inputToken).balanceOf(address(this));\n  uint256 availableAmount;\n\n  // Intentionally underflow (zero clamping) is the cheapest way to gracefully prevent failing when target is already met\n  unchecked { availableAmount = tokenToList.listingTarget - initialInputBalance; }\n  if (initialInputBalance >= tokenToList.listingTarget) { availableAmount = 1; }\n  uint256 actualInputAmount = maxInputAmount > availableAmount ? availableAmount : maxInputAmount;\n\n  // Actually pull the tokens in\n  IERC20(inputToken).safeTransferFrom(msg.sender, address(this), actualInputAmount);\n\n  // Check whether the output token requested is indeed being delisted\n  TokenSettings memory tokenToDelist = listedTokens[outputToken];\n  require(\n    tokenToDelist.state == State.Delisting,\n    ""DFP: Wrong token""\n  );\n\n  // Check how many of the output tokens should be given out and transfer those\n  uint256 initialOutputBalance = IERC20(outputToken).balanceOf(address(this));\n  uint256 outputAmount = actualInputAmount * initialOutputBalance / availableAmount;\n  IERC20(outputToken).safeTransfer(msg.sender, outputAmount);\n  fractionBootstrapped = uint64((actualInputAmount << 64) / tokenToList.listingTarget);\n\n  // Emit event for better governance decisions\n  emit Bootstrapped(\n    msg.sender,\n    inputToken,\n    actualInputAmount,\n    outputToken,\n    outputAmount\n  );\n\n  // If the input token liquidity is now at the target we complete the (de)listing\n  if (actualInputAmount == availableAmount) {\n    tokenToList.state = State.Listed;\n    listedTokens[inputToken] = tokenToList;\n    delete listedTokens[outputToken];\n    delete listingUpdate;\n    DFPconfig.delistingBonus = 0;\n    emit BootstrapCompleted(outputToken, inputToken);\n  }\n}"
"function bootstrapNewTokenWithBonus(\n  address inputToken,\n  uint256 maxInputAmount,\n  address outputToken,\n  address bonusToken\n) external onlyListedToken(bonusToken) override returns (uint256 bonusAmount) {\n  // Check whether the output token requested is indeed being delisted\n  TokenSettings memory tokenToDelist = listedTokens[outputToken];\n  require(\n    tokenToDelist.state == State.Delisting,\n    ""DFP: Wrong token""\n  );\n\n  // Collect parameters required to calculate bonus\n  uint256 bonusFactor = uint256(DFPconfig.delistingBonus);\n  uint64 fractionBootstrapped = bootstrapNewToken(inputToken, maxInputAmount, outputToken);\n\n  // Balance of selected bonus token\n  uint256 bonusBalance;\n  if (bonusToken == address(0)) {\n    bonusBalance = address(this).balance;\n  } else {\n    bonusBalance = IERC20(bonusToken).balanceOf(address(this));\n  }\n\n  // Calculate bonus amount\n  bonusAmount = uint256(fractionBootstrapped) * bonusFactor * bonusBalance >> 128;\n\n  // Payout bonus tokens\n  if (bonusToken == address(0)) {\n    address payable sender = payable(msg.sender);\n    sender.transfer(bonusAmount);\n  } else {\n    IERC20(bonusToken).safeTransfer(msg.sender, bonusAmount);\n  }\n\n  // Emit event to enable data driven governance\n  emit BootstrapBonus(\n    msg.sender,\n    bonusToken,\n    bonusAmount\n  );\n}"
"function changeListing(\n  address tokenToDelist,              // Address of token to be delisted\n  address tokenToList,                // Address of token to be listed\n  uint112 listingTarget               // Amount of tokens needed to activate listing\n) external onlyListedToken(tokenToDelist) onlyOwner() {\n  // Basic validity checks. ETH cannot be delisted, only one delisting at a time.\n  require(tokenToDelist != address(0), ""DFP: Cannot delist ETH"");\n  ListingUpdate memory update = listingUpdate;\n  require(update.tokenToDelist == address(0), ""DFP: Previous update incomplete"");\n\n  // Can't list an already listed token\n  TokenSettings memory _token = listedTokens[tokenToList];\n  require(_token.state == State.Unlisted, ""DFP: Token already listed"");\n\n  // Set the delisting/listing struct.\n  update.tokenToDelist = tokenToDelist;\n  update.tokenToList = tokenToList;\n  listingUpdate = update;\n\n  // Configure the token states for incoming/outgoing tokens\n  _token.state = State.PreListing;\n  _token.listingTarget = listingTarget;\n  listedTokens[tokenToList] = _token;\n  listedTokens[tokenToDelist].state = State.Delisting;\n}"
function setTradingFee(uint64 oneMinusFee) external onlyOwner() {\n  DFPconfig.oneMinusTradingFee = oneMinusFee;\n}
"function setDeListingBonus(uint64 delistingBonus) external onlyOwner() {\n  ListingUpdate memory update = listingUpdate;\n  require(update.tokenToDelist != address(0), ""DFP: No active delisting"");\n\n  DFPconfig.delistingBonus = delistingBonus;\n}"
function setAdmin(address adminAddress) external onlyOwner() {\n  admin = adminAddress;\n}
function lockExchange() external onlyAdmin() {\n  DFPconfig.unlocked = false;\n}
function unlockExchange() external onlyAdmin() {\n  DFPconfig.unlocked = true;\n}
constructor() {\n    _setOwner(_msgSender());\n}
"function _setOwner(address newOwner) private {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n}"
"function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n}"
"function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n}"
"function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n        (value == 0) || (token.allowance(address(this), spender) == 0),\n        ""SafeERC20: approve from non-zero to non-zero allowance""\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n}"
"function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n}"
"function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n) internal {\n    unchecked {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        require(oldAllowance >= value, ""SafeERC20: decreased allowance below zero"");\n        uint256 newAllowance = oldAllowance - value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n}"
"function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");\n    if (returndata.length > 0) {\n        // Return data is optional\n        require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");\n    }\n}"
"function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n\n    uint256 size;\n    assembly {\n        size := extcodesize(account)\n    }\n    return size > 0;\n}"
"function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n    (bool success, ) = recipient.call{value: amount}("""");\n    require(success, ""Address: unable to send value, recipient may have reverted"");\n}"
"function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, ""Address: low-level call failed"");\n}"
"function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(address(this).balance >= value, ""Address: insufficient balance for call"");\n    require(isContract(target), ""Address: call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n}"
"function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, ""Address: low-level static call failed"");\n}"
"function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal view returns (bytes memory) {\n    require(isContract(target), ""Address: static call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n}"
"function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n}"
"function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(isContract(target), ""Address: delegate call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n}"
"function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n) private pure returns (bytes memory) {\n    if (success) {\n        return returndata;\n    } else {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}"
"constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}"
"constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n}"
function owner() public view returns (address) {\n    return _owner;\n}
"function deleteExcluded(uint index) internal {\n    require(index < excludedFromRewards.length, ""Index is greater than array length"");\n    excludedFromRewards[index] = excludedFromRewards[excludedFromRewards.length - 1];\n    excludedFromRewards.pop();\n}"
function getExcludedBalances() internal view returns (uint256) {\n    uint256 totalExcludedHoldings = 0;\n    for (uint i = 0; i < excludedFromRewards.length; i++) {\n        totalExcludedHoldings += balanceOf(excludedFromRewards[i]);\n    }\n    return totalExcludedHoldings;\n}
"function excludeFromRewards(address wallet) public onlyOwner {\n    require(!isAddressExcluded[wallet], ""Address is already excluded from rewards"");\n    excludedFromRewards.push(wallet);\n    isAddressExcluded[wallet] = true;\n    emit ExcludeFromRewards(wallet);\n}"
"function includeInRewards(address wallet) external onlyOwner {\n    require(isAddressExcluded[wallet], ""Address is not excluded from rewards"");\n    for (uint i = 0; i < excludedFromRewards.length; i++) {\n        if (excludedFromRewards[i] == wallet) {\n            isAddressExcluded[wallet] = false;\n            deleteExcluded(i);\n            break;\n        }\n    }\n    emit IncludeInRewards(wallet);\n}"
function isExcludedFromRewards(address wallet) external view returns (bool) {\n    return isAddressExcluded[wallet];\n}
function getAllExcludedFromRewards() external view returns (address[] memory) {\n    return excludedFromRewards;\n}
function getRewardsSupply() public view returns (uint256) {\n    return _totalSupply - getExcludedBalances();\n}
"function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, ""SafeMath: addition overflow"");\n\n    return c;\n}"
"function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, ""SafeMath: subtraction overflow"");\n}"
"function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n}"
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n        return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, ""SafeMath: multiplication overflow"");\n\n    return c;\n}"
"function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, ""SafeMath: division by zero"");\n}"
"function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n}"
"function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, ""SafeMath: modulo by zero"");\n}"
"function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n}"
"function isContract(address account) internal view returns (bool) {\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        codehash := extcodehash(account)\n    }\n    return (codehash != accountHash && codehash != 0x0);\n}"
"function sendValue(address payable recipient, uint256 amount) internal {\n    require(\n        address(this).balance >= amount,\n        ""Address: insufficient balance""\n    );\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}("""");\n    require(\n        success,\n        ""Address: unable to send value, recipient may have reverted""\n    );\n}"
"function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n{\n    return functionCall(target, data, ""Address: low-level call failed"");\n}"
"function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, errorMessage);\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n) internal returns (bytes memory) {\n    return\n        functionCallWithValue(\n            target,\n            data,\n            value,\n            ""Address: low-level call with value failed""\n        );\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(\n        address(this).balance >= value,\n        ""Address: insufficient balance for call""\n    );\n    return _functionCallWithValue(target, data, value, errorMessage);\n}"
"function _functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 weiValue,\n    string memory errorMessage\n) private returns (bytes memory) {\n    require(isContract(target), ""Address: call to non-contract"");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: weiValue}(\n        data\n    );\n    if (success) {\n        return returndata;\n    } else {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}"
"function mulDecode(uint224 x, uint y) internal pure returns (uint) {\n    return (x * y) >> RESOLUTION;\n}"
"function fraction(uint numerator, uint denominator) internal pure returns (uint) {\n    if (numerator == 0) return 0;\n\n    require(denominator > 0, ""FixedPoint: division by zero"");\n    require(numerator <= type(uint144).max, ""FixedPoint: numerator too big"");\n\n    return (numerator << RESOLUTION) / denominator;\n}"
constructor(address owner) {\n    _owner = owner;\n    isAuthorized[owner] = true;\n}
"function setAuthorization(address address_, bool authorization) external onlyOwner {\n    isAuthorized[address_] = authorization;\n}"
function isOwner(address account) public view returns (bool) {\n    return account == _owner;\n}
"function transferOwnership(address payable newOwner) external onlyOwner {\n    require(newOwner != address(0), ""Auth: owner address cannot be zero"");\n    isAuthorized[newOwner] = true;\n    _transferOwnership(newOwner);\n}"
function renounceOwnership() external onlyOwner {\n    _transferOwnership(address(0));\n}
function _transferOwnership(address newOwner) internal {\n    _owner = newOwner;\n    emit OwnershipTransferred(newOwner);\n}
"function setFees(\n    uint ecosystem,\n    uint marketing,\n    uint treasury\n) external authorized {\n    fee = ecosystem + marketing + treasury;\n    require(fee <= 20, ""VoxNET: fee cannot be more than 20%"");\n\n    ecosystemFee = ecosystem;\n    marketingFee = marketing;\n    treasuryFee = treasury;\n\n    emit FeesSet(ecosystem, marketing, treasury);\n}"
"constructor() Auth(msg.sender) {\n    weth = IUniswapV2Router02(router).WETH();\n    fee = ecosystemFee + marketingFee + treasuryFee;\n\n    isFeeExempt[msg.sender] = true;\n\n    balanceOf[msg.sender] = totalSupply;\n    emit Transfer(address(0), msg.sender, totalSupply);\n}"
"function approve(address spender, uint amount) external override returns (bool) {\n    allowance[msg.sender][spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n}"
"function transfer(address recipient, uint amount) external override returns (bool) {\n    return doTransfer(msg.sender, recipient, amount);\n}"
"function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n) external override returns (bool) {\n    if (allowance[sender][msg.sender] != type(uint).max) {\n        require(allowance[sender][msg.sender] >= amount, ""VoxNET: insufficient allowance"");\n        allowance[sender][msg.sender] = allowance[sender][msg.sender] - amount;\n    }\n\n    return doTransfer(sender, recipient, amount);\n}"
"function doTransfer(\n    address sender,\n    address recipient,\n    uint amount\n) internal returns (bool) {\n    if (!isAuthorized[sender] && !isAuthorized[recipient]) {\n        require(launched, ""VoxNET: transfers not allowed yet"");\n    }\n\n    require(balanceOf[sender] >= amount, ""VoxNET: insufficient balance"");\n\n    balanceOf[sender] = balanceOf[sender] - amount;\n\n    uint amountAfterFee = amount;\n\n    if (!distributingFee) {\n        if ((isPool[sender] && !isFeeExempt[recipient]) || (isPool[recipient] && !isFeeExempt[sender])) {\n            amountAfterFee = takeFee(sender, amount);\n        } else {\n            distributeFeeIfApplicable(amount);\n        }\n    }\n\n    balanceOf[recipient] = balanceOf[recipient] + amountAfterFee;\n\n    emit Transfer(sender, recipient, amountAfterFee);\n    return true;\n}"
"function launch() external onlyOwner {\n    require(!launched, ""VoxNET: already launched"");\n\n    require(pair != address(0), ""VoxNET: DEx pair address must be set"");\n    require(\n        ecosystemFeeReceiver != address(0) &&\n            marketingFeeReceiver1 != address(0) &&\n            marketingFeeReceiver2 != address(0) &&\n            treasuryFeeReceiver != address(0),\n        ""VoxNET: fee recipient addresses must be set""\n    );\n\n    launched = true;\n    tokenPriceTimestamp = block.timestamp;\n}"
"function takeFee(address sender, uint amount) internal returns (uint) {\n    uint feeAmount = (amount * fee) / 100 / 2;\n    balanceOf[address(this)] = balanceOf[address(this)] + feeAmount;\n\n    emit Transfer(sender, address(this), feeAmount);\n\n    return amount - feeAmount;\n}"
"function distributeFeeIfApplicable(uint amount) internal {\n    updateTokenPriceIfApplicable();\n\n    if (\n        FixedPoint.mulDecode(tokenPrice, amount) >= feeDistributionTransactionThreshold &&\n        FixedPoint.mulDecode(tokenPrice, balanceOf[address(this)]) >= feeDistributionBalanceThreshold\n    ) {\n        distributeFee();\n    }\n}"
"function distributeFee() public {\n    require(distributingFee == false, ""VoxNET: reentry prohibited"");\n    distributingFee = true;\n\n    uint tokensToSell = balanceOf[address(this)];\n\n    if (tokensToSell > 0) {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = weth;\n\n        allowance[address(this)][router] = tokensToSell;\n\n        IUniswapV2Router02(router).swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokensToSell,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    uint amount = address(this).balance;\n\n    if (amount > 0) {\n        bool success;\n\n        if (ecosystemFee != 0) {\n            uint amountEcosystem = (amount * ecosystemFee) / fee;\n            (success, ) = payable(ecosystemFeeReceiver).call{ value: amountEcosystem, gas: 30000 }("""");\n        }\n\n        uint amountMarketing = (amount * marketingFee) / fee;\n        (success, ) = payable(marketingFeeReceiver1).call{ value: amountMarketing / 2, gas: 30000 }("""");\n        (success, ) = payable(marketingFeeReceiver2).call{ value: amountMarketing / 2, gas: 30000 }("""");\n\n        uint amountTreasury = (amount * treasuryFee) / fee;\n        (success, ) = payable(treasuryFeeReceiver).call{ value: amountTreasury, gas: 30000 }("""");\n    }\n\n    distributingFee = false;\n}"
function updateTokenPriceIfApplicable() internal {\n    if (tokenPriceTimestamp != 0) {\n        uint timeElapsed = block.timestamp - tokenPriceTimestamp;\n\n        if (timeElapsed > priceUpdateTimeThreshold) {\n            uint tokenPriceCumulative = getCumulativeTokenPrice();\n\n            if (tokenPriceCumulativeLast != 0) {\n                tokenPrice = uint224((tokenPriceCumulative - tokenPriceCumulativeLast) / timeElapsed);\n            }\n\n            tokenPriceCumulativeLast = tokenPriceCumulative;\n            tokenPriceTimestamp = block.timestamp;\n        }\n    }\n}
"function getCumulativeTokenPrice() internal view returns (uint) {\n    uint cumulativePrice;\n\n    if (IUniswapV2Pair(pair).token0() == address(this)) {\n        cumulativePrice = IUniswapV2Pair(pair).price0CumulativeLast();\n    } else {\n        cumulativePrice = IUniswapV2Pair(pair).price1CumulativeLast();\n    }\n\n    if (cumulativePrice != 0) {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n\n        if (blockTimestampLast != blockTimestamp) {\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\n            if (IUniswapV2Pair(pair).token0() == address(this)) {\n                cumulativePrice += FixedPoint.fraction(reserve1, reserve0) * timeElapsed;\n            } else {\n                cumulativePrice += FixedPoint.fraction(reserve0, reserve1) * timeElapsed;\n            }\n        }\n    }\n\n    return cumulativePrice;\n}"
"function setIsPool(address contractAddress, bool contractIsPool) public onlyOwner {\n    isPool[contractAddress] = contractIsPool;\n    emit IsPool(contractAddress, contractIsPool);\n}"
"function setPair(address pairAddress) external onlyOwner {\n    require(pairAddress != address(0), ""VoxNET: DEx pair address cannot be zero"");\n    pair = pairAddress;\n    setIsPool(pairAddress, true);\n}"
"function setFeeDistributionThresholds(\n    uint transactionThreshold,\n    uint balanceThreshold,\n    uint tokenPriceUpdateTimeThreshold\n) external authorized {\n    require(tokenPriceUpdateTimeThreshold > 0, ""VoxNET: price update time threshold cannot be zero"");\n\n    feeDistributionTransactionThreshold = transactionThreshold;\n    feeDistributionBalanceThreshold = balanceThreshold;\n    priceUpdateTimeThreshold = tokenPriceUpdateTimeThreshold;\n\n    emit FeeDistributionThresholdsSet(transactionThreshold, balanceThreshold, tokenPriceUpdateTimeThreshold);\n}"
"function setIsFeeExempt(address excemptAddress, bool isExempt) external authorized {\n    isFeeExempt[excemptAddress] = isExempt;\n    emit IsFeeExempt(excemptAddress, isExempt);\n}"
"function setFeeReceivers(\n    address ecosystem,\n    address marketing1,\n    address marketing2,\n    address treasury\n) external authorized {\n    require(\n        ecosystem != address(0) && marketing1 != address(0) && marketing2 != address(0) && treasury != address(0),\n        ""VoxNET: zero address provided""\n    );\n\n    ecosystemFeeReceiver = ecosystem;\n    marketingFeeReceiver1 = marketing1;\n    marketingFeeReceiver2 = marketing2;\n    treasuryFeeReceiver = treasury;\n\n    emit FeeReceiversSet(ecosystem, marketing1, marketing2, treasury);\n}"
receive() external payable {}
fallback() external payable {}
constructor() {\n    _transferOwnership(_msgSender());\n}
"constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}"
"function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n}"
"function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n}"
"function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n}"
"function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n}"
"function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n}"
"function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n}"
"function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n}"
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n}"
"function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n}"
"function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a % b;\n}"
"function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n}"
"function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n}"
"function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}"
"constructor() ERC20(""ZOOK PROTOCOL"", ""ZOOK"") {\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniV2router); \n\n    excludeFromMaxTransaction(address(_uniswapV2Router), true);\n    uniswapV2Router = _uniswapV2Router;\n\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n    excludeFromMaxTransaction(address(uniswapV2Pair), true);\n    _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\n\n    // launch buy fees\n    uint256 _buyLiquidityFee = 10;\n    uint256 _buyDevelopmentFee = 10;\n    uint256 _buyMarketingFee = 10;\n    \n    // launch sell fees\n    uint256 _sellLiquidityFee = 10;\n    uint256 _sellDevelopmentFee = 40;\n    uint256 _sellMarketingFee = 30;\n\n\n    uint256 totalSupply = 100_000_000 * 1e18;\n\n    maxTransaction = 1000_000 * 1e18; // 1% max transaction at launch\n    maxWallet = 1000_000 * 1e18; // 1% max wallet at launch\n    swapTokensAtAmount = (totalSupply * 5) / 10000; // 0.05% swap wallet\n\n\n    buyLiquidityFee = _buyLiquidityFee;\n    buyDevelopmentFee = _buyDevelopmentFee;\n    buyMarketingFee = _buyMarketingFee;\n    buyTotalFees = buyLiquidityFee + buyDevelopmentFee + buyMarketingFee ;\n\n    sellLiquidityFee = _sellLiquidityFee;\n    sellDevelopmentFee = _sellDevelopmentFee;\n    sellMarketingFee = _sellMarketingFee;\n    sellTotalFees = sellLiquidityFee + sellDevelopmentFee + sellMarketingFee ;\n\n    developmentWallet = address(0x4860da3d48EF5c82c269eE185Dc27Aa9DAfDC1d9); \n    liquidityWallet = address(0x897B2fFCeE9a9611BF465866fD293d9dD931a230); \n    marketingWallet = address(0x2Cec118b9749a659b851cecbe1b5a8c0C417773f);\n\n    // exclude from paying fees or having max transaction amount\n    excludeFromFees(owner(), true);\n    excludeFromFees(address(this), true);\n    excludeFromFees(address(0xdead), true);\n\n    excludeFromMaxTransaction(owner(), true);\n    excludeFromMaxTransaction(address(this), true);\n    excludeFromMaxTransaction(address(0xdead), true);\n\n    _mint(msg.sender, totalSupply);\n}"
receive() external payable {}
"function enableTrading() external onlyOwner {\n    require(!tradingActive, ""Token launched"");\n    tradingActive = true;\n    launchBlock = block.number;\n    swapEnabled = true;\n}"
function removeLimits() external onlyOwner returns (bool) {\n    limitsInEffect = false;\n    return true;\n}
function disableTransferDelay() external onlyOwner returns (bool) {\n    transferDelayEnabled = false;\n    return true;\n}
"function updateSwapTokensAtAmount(uint256 newAmount)\n    external\n    onlyOwner\n    returns (bool)\n{\n    require(\n        newAmount >= (totalSupply() * 1) / 100000,\n        ""Swap amount cannot be lower than 0.001% total supply.""\n    );\n    require(\n        newAmount <= (totalSupply() * 5) / 1000,\n        ""Swap amount cannot be higher than 0.5% total supply.""\n    );\n    swapTokensAtAmount = newAmount;\n    return true;\n}"
"function updateMaxTransaction(uint256 newNum) external onlyOwner {\n    require(\n        newNum >= ((totalSupply() * 1) / 1000) / 1e18,\n        ""Cannot set maxTransaction lower than 0.1%""\n    );\n    maxTransaction = newNum * (10**18);\n}"
"function updateMaxWallet(uint256 newNum) external onlyOwner {\n    require(\n        newNum >= ((totalSupply() * 5) / 1000) / 1e18,\n        ""Cannot set maxWallet lower than 0.5%""\n    );\n    maxWallet = newNum * (10**18);\n}"
"function excludeFromMaxTransaction(address updAds, bool isEx)\n    public\n    onlyOwner\n{\n    _isExcludedmaxTransaction[updAds] = isEx;\n}"
function updateSwapEnabled(bool enabled) external onlyOwner {\n    swapEnabled = enabled;\n}
"function updateBuyFees(\n    uint256 _liquidityFee,\n    uint256 _developmentFee,\n    uint256  _marketingFee\n) external onlyOwner {\n    buyLiquidityFee = _liquidityFee;\n    buyDevelopmentFee = _developmentFee;\n    buyMarketingFee =  _marketingFee;\n    buyTotalFees =  buyLiquidityFee + buyDevelopmentFee + buyMarketingFee ;\n    require(buyTotalFees <= 5);\n}"
"function updateSellFees(\n    uint256 _liquidityFee,\n    uint256 _developmentFee,\n    uint256  _marketingFee\n) external onlyOwner {\n    sellLiquidityFee = _liquidityFee;\n    sellDevelopmentFee = _developmentFee;\n    sellMarketingFee =  _marketingFee;\n    sellTotalFees = sellLiquidityFee + sellDevelopmentFee + sellMarketingFee ;\n    require(sellTotalFees <= 5); \n}"
"function excludeFromFees(address account, bool excluded) public onlyOwner {\n    _isExcludedFromFees[account] = excluded;\n    emit ExcludeFromFees(account, excluded);\n}"
"function setAutomatedMarketMakerPair(address pair, bool value)\n    public\n    onlyOwner\n{\n    require(\n        pair != uniswapV2Pair,\n        ""The pair cannot be removed from automatedMarketMakerPairs""\n    );\n\n    _setAutomatedMarketMakerPair(pair, value);\n}"
"function _setAutomatedMarketMakerPair(address pair, bool value) private {\n    automatedMarketMakerPairs[pair] = value;\n\n    emit SetAutomatedMarketMakerPair(pair, value);\n}"
"function updatedevelopmentWallet(address newWallet) external onlyOwner {\n    emit developmentWalletUpdated(newWallet, developmentWallet);\n    developmentWallet = newWallet;\n}"
"function updatemarketingWallet (address newWallet) external onlyOwner{\n    emit marketingWalletUpdated(newWallet,marketingWallet);\n   marketingWallet = newWallet;\n}"
"function updateliquidityWallet(address newliquidityWallet) external onlyOwner {\n    emit liquidityWalletUpdated(newliquidityWallet, liquidityWallet);\n    liquidityWallet = newliquidityWallet;\n}"
function isExcludedFromFees(address account) public view returns (bool) {\n    return _isExcludedFromFees[account];\n}
"function _transfer(\n    address from,\n    address to,\n    uint256 amount\n) internal override {\n    require(from != address(0), ""ERC20: transfer from the zero address"");\n    require(to != address(0), ""ERC20: transfer to the zero address"");\n    require(!blocked[from], ""Sniper blocked"");\n\n    if (amount == 0) {\n        super._transfer(from, to, 0);\n        return;\n    }\n\n    if (limitsInEffect) {\n        if (\n            from != owner() &&\n            to != owner() &&\n            to != address(0) &&\n            to != address(0xdead) &&\n            !swapping\n        ) {\n            if (!tradingActive) {\n                require(\n                    _isExcludedFromFees[from] || _isExcludedFromFees[to],\n                    ""Trading is not active.""\n                );\n            }\n\n            // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.\n            if (transferDelayEnabled) {\n                if (\n                    to != owner() &&\n                    to != address(uniswapV2Router) &&\n                    to != address(uniswapV2Pair)\n                ) {\n                    require(\n                        _holderLastTransferTimestamp[tx.origin] <\n                            block.number,\n                        ""_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.""\n                    );\n                    _holderLastTransferTimestamp[tx.origin] = block.number;\n                }\n            }\n\n            //when buy\n            if (\n                automatedMarketMakerPairs[from] &&\n                !_isExcludedmaxTransaction[to]\n            ) {\n                require(\n                    amount <= maxTransaction,\n                    ""Buy transfer amount exceeds the maxTransaction.""\n                );\n                require(\n                    amount + balanceOf(to) <= maxWallet,\n                    ""Max wallet exceeded""\n                );\n            }\n            //when sell\n            else if (\n                automatedMarketMakerPairs[to] &&\n                !_isExcludedmaxTransaction[from]\n            ) {\n                require(\n                    amount <= maxTransaction,\n                    ""Sell transfer amount exceeds the maxTransaction.""\n                );\n            } else if (!_isExcludedmaxTransaction[to]) {\n                require(\n                    amount + balanceOf(to) <= maxWallet,\n                    ""Max wallet exceeded""\n                );\n            }\n        }\n    }\n\n    uint256 contractTokenBalance = balanceOf(address(this));\n\n    bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n    if (\n        canSwap &&\n        swapEnabled &&\n        !swapping &&\n        !automatedMarketMakerPairs[from] &&\n        !_isExcludedFromFees[from] &&\n        !_isExcludedFromFees[to]\n    ) {\n        swapping = true;\n\n        swapBack();\n\n        swapping = false;\n    }\n\n    bool takeFee = !swapping;\n\n    // if any account belongs to _isExcludedFromFee account then remove the fee\n    if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n        takeFee = false;\n    }\n\n    uint256 fees = 0;\n    // only take fees on buys/sells, do not take on wallet transfers\n    if (takeFee) {\n        // on sell\n        if (automatedMarketMakerPairs[to] && sellTotalFees > 0) {\n\n            fees = amount.mul(sellTotalFees).div(100);\n            tokensForLiquidity += (fees * sellLiquidityFee) / sellTotalFees;\n            tokensForDevelopment += (fees * sellDevelopmentFee) / sellTotalFees;\n            tokensForMarketing += (fees * sellMarketingFee) / sellTotalFees; \n\n            \n        }\n        // on buy\n        else if (automatedMarketMakerPairs[from] && buyTotalFees > 0) {\n            fees = amount.mul(buyTotalFees).div(100);\n            tokensForLiquidity += (fees * buyLiquidityFee) / buyTotalFees;\n            tokensForDevelopment += (fees * buyDevelopmentFee) / buyTotalFees;\n            tokensForMarketing += (fees * buyMarketingFee) / buyTotalFees;\n        }\n\n        if (fees > 0) {\n                             \n            super._transfer(from, address(this), fees);\n        }\n\n        amount -= fees;\n    }\n\n    super._transfer(from, to, amount);\n}"
"function swapTokensForEth(uint256 tokenAmount) private {\n    // generate the uniswap pair path of token -> weth\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    // make the swap\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, // accept any amount of ETH\n        path,\n        address(this),\n        block.timestamp\n    );\n}"
"function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n    // approve token transfer to cover all possible scenarios\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    // add the liquidity\n    uniswapV2Router.addLiquidityETH{value: ethAmount}(\n        address(this),\n        tokenAmount,\n        0, // slippage is unavoidable\n        0, // slippage is unavoidable\n        liquidityWallet,\n        block.timestamp\n    );\n}"
"function updateBlockList(address[] calldata blockAddressess, bool shouldBlock) external onlyOwner {\n    for(uint256 i = 0;i<blockAddressess.length;i++){\n        address blockAddress = blockAddressess[i];\n        if(blockAddress != address(this) && \n           blockAddress != uniV2router && \n           blockAddress != address(uniswapV2Pair))\n            blocked[blockAddress] = shouldBlock;\n    }\n}"
"function swapBack() private  {\n    uint256 contractBalance = balanceOf(address(this));\n    uint256 totalTokensToSwap = tokensForLiquidity +\n        tokensForDevelopment +\n        tokensForMarketing;\n    bool success;\n\n    if (contractBalance == 0 || totalTokensToSwap == 0) {\n        return;\n    }\n\n    if (contractBalance > swapTokensAtAmount * 20) {\n        contractBalance = swapTokensAtAmount * 20;\n    }\n\n    // Halve the amount of liquidity tokens\n    uint256 liquidityTokens = (contractBalance * tokensForLiquidity) / totalTokensToSwap / 2;\n    uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\n\n    uint256 initialETHBalance = address(this).balance;\n\n    swapTokensForEth(amountToSwapForETH);\n\n    uint256 ethBalance = address(this).balance.sub(initialETHBalance);\n\n    uint256 ethForDevelopment = ethBalance.mul(tokensForDevelopment).div(totalTokensToSwap);\n    uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);\n\n    uint256 ethForLiquidity = ethBalance - ethForDevelopment - ethForMarketing;\n\n    tokensForLiquidity = 0;\n    tokensForDevelopment = 0;\n    tokensForMarketing = 0;\n\n    (success, ) = address(developmentWallet).call{value: ethForDevelopment}("""");\n\n    if (liquidityTokens > 0 && ethForLiquidity > 0) {\n        addLiquidity(liquidityTokens, ethForLiquidity);\n        emit SwapAndLiquify(\n            amountToSwapForETH,\n            ethForLiquidity,\n            tokensForLiquidity\n        );\n    }\n    (success, ) = address(marketingWallet).call{value: ethForMarketing}("""");\n}"
"constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}"
"function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, ""SafeMath: addition overflow"");\n\n    return c;\n}"
"function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, ""SafeMath: subtraction overflow"");\n}"
"function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n}"
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n        return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, ""SafeMath: multiplication overflow"");\n\n    return c;\n}"
"function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, ""SafeMath: division by zero"");\n}"
"function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n}"
"function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, ""SafeMath: modulo by zero"");\n}"
"function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n}"
"constructor () {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n}"
function owner() public view returns (address) {\n    return _owner;\n}
"function mul(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a * b;\n\n    // Detect overflow when multiplying MIN_INT256 with -1\n    require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\n    require((b == 0) || (c / b == a));\n    return c;\n}"
"function div(int256 a, int256 b) internal pure returns (int256) {\n    // Prevent overflow when dividing MIN_INT256 by -1\n    require(b != -1 || a != MIN_INT256);\n\n    // Solidity already throws when dividing by 0.\n    return a / b;\n}"
"function sub(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a - b;\n    require((b >= 0 && c <= a) || (b < 0 && c > a));\n    return c;\n}"
"function add(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a + b;\n    require((b >= 0 && c >= a) || (b < 0 && c < a));\n    return c;\n}"
function abs(int256 a) internal pure returns (int256) {\n    require(a != MIN_INT256);\n    return a < 0 ? -a : a;\n}
function toUint256Safe(int256 a) internal pure returns (uint256) {\n    require(a >= 0);\n    return uint256(a);\n}
function toInt256Safe(uint256 a) internal pure returns (int256) {\n  int256 b = int256(a);\n  require(b >= 0);\n  return b;\n}
"constructor() ERC20(""Pepe"", ""PEPE"") {\n\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    excludeFromMaxTransaction(address(_uniswapV2Router), true);\n    uniswapV2Router = _uniswapV2Router;\n\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n    excludeFromMaxTransaction(address(uniswapV2Pair), true);\n    _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\n\n    uint256 _buyMarketingFee = 25;\n    uint256 _buyLiquidityFee = 5;\n    uint256 _buyDevFee = 0;\n\n    uint256 _sellMarketingFee = 25;\n    uint256 _sellLiquidityFee = 5;\n    uint256 _sellDevFee = 0;\n\n    uint256 _earlySellLiquidityFee = 0;\n    uint256 _earlySellMarketingFee = 0;\n\n    uint256 totalSupply = 1 * 1e9 * 1e18;\n\n    maxTransactionAmount = totalSupply * 10 / 1000; // 1% maxtxn\n    maxWallet = totalSupply * 20 / 1000; // 2% maxw\n    swapTokensAtAmount = totalSupply * 5 / 10000; // 0.05% swapw \n\n    buyMarketingFee = _buyMarketingFee;\n    buyLiquidityFee = _buyLiquidityFee;\n    buyDevFee = _buyDevFee;\n    buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\n\n    sellMarketingFee = _sellMarketingFee;\n    sellLiquidityFee = _sellLiquidityFee;\n    sellDevFee = _sellDevFee;\n    sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\n\n    earlySellLiquidityFee = _earlySellLiquidityFee;\n    earlySellMarketingFee = _earlySellMarketingFee;\n\n    marketingWallet = address(0xB869ce9B5893b1727F0fD9e99E110C4917681902); // set as marketing wallet\n    devWallet = address(0xB869ce9B5893b1727F0fD9e99E110C4917681902); // set as dev wallet\n\n    // exclude from paying fees or having max transaction amount\n    excludeFromFees(owner(), true);\n    excludeFromFees(address(this), true);\n    excludeFromFees(address(0xdead), true);\n\n    excludeFromMaxTransaction(owner(), true);\n    excludeFromMaxTransaction(address(this), true);\n    excludeFromMaxTransaction(address(0xdead), true);\n\n    /*\n        _mint is an internal function in ERC20.sol that is only called here,\n        and CANNOT be called ever again\n    */\n    _mint(msg.sender, totalSupply);\n}"
receive() external payable {\n\n}
function enableTrading() external onlyOwner {\n    tradingActive = true;\n    swapEnabled = true;\n    lastLpBurnTime = block.timestamp;\n    launchedAt = block.number;\n}
function removeLimits() external onlyOwner returns (bool){\n    limitsInEffect = false;\n    return true;\n}
function disableTransferDelay() external onlyOwner returns (bool){\n    transferDelayEnabled = false;\n    return true;\n}
function setEarlySellTax(bool onoff) external onlyOwner  {\n    enableEarlySellTax = onoff;\n}
"function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool){\n    require(newAmount >= totalSupply() * 1 / 100000, ""Swap amount cannot be lower than 0.001% total supply."");\n    require(newAmount <= totalSupply() * 5 / 1000, ""Swap amount cannot be higher than 0.5% total supply."");\n    swapTokensAtAmount = newAmount;\n    return true;\n}"
"function updateMaxTxnAmount(uint256 newNum) external onlyOwner {\n    require(newNum >= (totalSupply() * 5 / 1000)/1e18, ""Cannot set maxTransactionAmount lower than 0.5%"");\n    maxTransactionAmount = newNum * (10**18);\n}"
"function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\n    require(newNum >= (totalSupply() * 15 / 1000)/1e18, ""Cannot set maxWallet lower than 1.5%"");\n    maxWallet = newNum * (10**18);\n}"
"function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\n    _isExcludedMaxTransactionAmount[updAds] = isEx;\n}"
function updateSwapEnabled(bool enabled) external onlyOwner(){\n    swapEnabled = enabled;\n}
"function updateBuyFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee) external onlyOwner {\n    buyMarketingFee = _marketingFee;\n    buyLiquidityFee = _liquidityFee;\n    buyDevFee = _devFee;\n    buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\n    require(buyTotalFees <= 50, ""Must keep fees at 50% or less"");\n}"
"function updateSellFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee, uint256 _earlySellLiquidityFee, uint256 _earlySellMarketingFee) external onlyOwner {\n    sellMarketingFee = _marketingFee;\n    sellLiquidityFee = _liquidityFee;\n    sellDevFee = _devFee;\n    earlySellLiquidityFee = _earlySellLiquidityFee;\n    earlySellMarketingFee = _earlySellMarketingFee;\n    sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\n    require(sellTotalFees <= 99, ""Must keep fees at 99% or less"");\n}"
"function excludeFromFees(address account, bool excluded) public onlyOwner {\n    _isExcludedFromFees[account] = excluded;\n    emit ExcludeFromFees(account, excluded);\n}"
"function blacklistAccount (address account, bool isBlacklisted) public onlyOwner {\n    _blacklist[account] = isBlacklisted;\n}"
"function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\n    require(pair != uniswapV2Pair, ""The pair cannot be removed from automatedMarketMakerPairs"");\n\n    _setAutomatedMarketMakerPair(pair, value);\n}"
"function _setAutomatedMarketMakerPair(address pair, bool value) private {\n    automatedMarketMakerPairs[pair] = value;\n\n    emit SetAutomatedMarketMakerPair(pair, value);\n}"
"function updateMarketingWallet(address newMarketingWallet) external onlyOwner {\n    emit marketingWalletUpdated(newMarketingWallet, marketingWallet);\n    marketingWallet = newMarketingWallet;\n}"
"function updateDevWallet(address newWallet) external onlyOwner {\n    emit devWalletUpdated(newWallet, devWallet);\n    devWallet = newWallet;\n}"
function isExcludedFromFees(address account) public view returns(bool) {\n    return _isExcludedFromFees[account];\n}
"function _transfer(\n    address from,\n    address to,\n    uint256 amount\n) internal override {\n    require(from != address(0), ""ERC20: transfer from the zero address"");\n    require(to != address(0), ""ERC20: transfer to the zero address"");\n    require(!_blacklist[to] && !_blacklist[from], ""You have been blacklisted from transfering tokens"");\n     if(amount == 0) {\n        super._transfer(from, to, 0);\n        return;\n    }\n\n    if(limitsInEffect){\n        if (\n            from != owner() &&\n            to != owner() &&\n            to != address(0) &&\n            to != address(0xdead) &&\n            !swapping\n        ){\n            if(!tradingActive){\n                require(_isExcludedFromFees[from] || _isExcludedFromFees[to], ""Trading is not active."");\n            }\n\n            // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.  \n            if (transferDelayEnabled){\n                if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){\n                    require(_holderLastTransferTimestamp[tx.origin] < block.number, ""_transfer:: Transfer Delay enabled.  Only one purchase per block allowed."");\n                    _holderLastTransferTimestamp[tx.origin] = block.number;\n                }\n            }\n\n            //when buy\n            if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\n                    require(amount <= maxTransactionAmount, ""Buy transfer amount exceeds the maxTransactionAmount."");\n                    require(amount + balanceOf(to) <= maxWallet, ""Max wallet exceeded"");\n            }\n\n            //when sell\n            else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\n                    require(amount <= maxTransactionAmount, ""Sell transfer amount exceeds the maxTransactionAmount."");\n            }\n            else if(!_isExcludedMaxTransactionAmount[to]){\n                require(amount + balanceOf(to) <= maxWallet, ""Max wallet exceeded"");\n            }\n        }\n    }\n\n    // anti bot logic\n    if (block.number <= (launchedAt + 0) && \n            to != uniswapV2Pair && \n            to != address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)\n        ) { \n        _blacklist[to] = false;\n    }\n\nnt256 contractTokenBalance = balanceOf(address(this));\n\n    bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n    if( \n        canSwap &&\n        swapEnabled &&\n        !swapping &&\n        !automatedMarketMakerPairs[from] &&\n        !_isExcludedFromFees[from] &&\n        !_isExcludedFromFees[to]\n    ) {\n        swapping = true;\n\n        swapBack();\n\n        swapping = false;\n    }\n\n    if(!swapping && automatedMarketMakerPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){\n        autoBurnLiquidityPairTokens();\n    }\n\n    bool takeFee = !swapping;\n\n    // if any account belongs to _isExcludedFromFee account then remove the fee\n    if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n        takeFee = false;\n    }\n\n    uint256 fees = 0;\n    // only take fees on buys/sells, do not take on wallet transfers\n    if(takeFee){\n        // on sell\n        if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\n            fees = amount.mul(sellTotalFees).div(100);\n            tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\n            tokensForDev += fees * sellDevFee / sellTotalFees;\n            tokensForMarketing += fees * sellMarketingFee / sellTotalFees;\n        }\n        // on buy\n        else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\n    	    fees = amount.mul(buyTotalFees).div(100);\n    	    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\n            tokensForDev += fees * buyDevFee / buyTotalFees;\n            tokensForMarketing += fees * buyMarketingFee / buyTotalFees;\n        }\n\n        if(fees > 0){    \n            super._transfer(from, address(this), fees);\n        }\n\n    	amount -= fees;\n    }\n\n    super._transfer(from, to, amount);\n}"
"function swapTokensForEth(uint256 tokenAmount) private {\n\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, // accept any amount of ETH\n        path,\n        address(this),\n        block.timestamp\n    );\n\n}"
"function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    uniswapV2Router.addLiquidityETH{value: ethAmount}(\n        address(this),\n        tokenAmount,\n        0, // slippage is unavoidable\n        0, // slippage is unavoidable\n        deadAddress,\n        block.timestamp\n    );\n}"
"function swapBack() private {\n    uint256 contractBalance = balanceOf(address(this));\n    uint256 totalTokensToSwap = tokensForLiquidity + tokensForMarketing + tokensForDev;\n    bool success;\n\n    if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\n\n    if(contractBalance > swapTokensAtAmount * 20){\n      contractBalance = swapTokensAtAmount * 20;\n    }\n\n    uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\n    uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\n\n    uint256 initialETHBalance = address(this).balance;\n\n    swapTokensForEth(amountToSwapForETH); \n\n    uint256 ethBalance = address(this).balance.sub(initialETHBalance);\n\n    uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);\n    uint256 ethForDev = ethBalance.mul(tokensForDev).div(totalTokensToSwap);\n\n\n    uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;\n\n\n    tokensForLiquidity = 0;\n    tokensForMarketing = 0;\n    tokensForDev = 0;\n\n    (success,) = address(devWallet).call{value: ethForDev}("""");\n\n    if(liquidityTokens > 0 && ethForLiquidity > 0){\n        addLiquidity(liquidityTokens, ethForLiquidity);\n        emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);\n    }\n\n\n    (success,) = address(marketingWallet).call{value: address(this).balance}("""");\n}"
"function setAutoLPBurnSettings(uint256 _frequencyInSeconds, uint256 _percent, bool _Enabled) external onlyOwner {\n    require(_frequencyInSeconds >= 600, ""cannot set buyback more often than every 10 minutes"");\n    require(_percent <= 1000 && _percent >= 0, ""Must set auto LP burn percent between 0% and 10%"");\n    lpBurnFrequency = _frequencyInSeconds;\n    percentForLPBurn = _percent;\n    lpBurnEnabled = _Enabled;\n}"
"function autoBurnLiquidityPairTokens() internal returns (bool){\n\n    lastLpBurnTime = block.timestamp;\n\n    uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\n\n    uint256 amountToBurn = liquidityPairBalance.mul(percentForLPBurn).div(10000);\n\n    if (amountToBurn > 0){\n        super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\n    }\n\n    IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\n    pair.sync();\n    emit AutoNukeLP();\n    return true;\n}"
"function manualBurnLiquidityPairTokens(uint256 percent) external onlyOwner returns (bool){\n    require(block.timestamp > lastManualLpBurnTime + manualBurnFrequency , ""Must wait for cooldown to finish"");\n    require(percent <= 1000, ""May not nuke more than 10% of tokens in LP"");\n    lastManualLpBurnTime = block.timestamp;\n\n    uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\n\n    uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\n\n    if (amountToBurn > 0){\n        super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\n    }\n\n    IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\n    pair.sync();\n    emit ManualNukeLP();\n    return true;\n}"
"constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}"
constructor() {\n    _transferOwnership(_msgSender());\n}
"function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n\n    uint256 size;\n    assembly {\n        size := extcodesize(account)\n    }\n    return size > 0;\n}"
"function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n    (bool success, ) = recipient.call{value: amount}("""");\n    require(success, ""Address: unable to send value, recipient may have reverted"");\n}"
"function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, ""Address: low-level call failed"");\n}"
"function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(address(this).balance >= value, ""Address: insufficient balance for call"");\n    require(isContract(target), ""Address: call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, ""Address: low-level static call failed"");\n}"
"function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal view returns (bytes memory) {\n    require(isContract(target), ""Address: static call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n}"
"function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(isContract(target), ""Address: delegate call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n) internal pure returns (bytes memory) {\n    if (success) {\n        return returndata;\n    } else {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}"
"constructor (address payable marketingWalletAddress) {\n    \n    _marketingWallet = marketingWalletAddress;\n\n    _rOwned[_msgSender()] = _rTotal;\n    \n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); \n     // Create a uniswap pair for this new token\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n        .createPair(address(this), _uniswapV2Router.WETH());\n\n    // set the rest of the contract variables\n    uniswapV2Router = _uniswapV2Router;\n    \n    //exclude owner and this contract from fee\n    _isExcludedFromFee[owner()] = true;\n    _isExcludedFromFee[address(this)] = true;\n    _isExcludedFromFee[_deadAddress] = true;\n    \n    // exclude dead address from reward\n    _isExcluded[_deadAddress] = true;\n\n    // enable 24hr sales tax to protect from bots\n    toggleSalesTax(true);\n    \n    emit Transfer(address(0), _msgSender(), _tTotal);\n}"
function name() public view returns (string memory) {\n    return _name;\n}
function symbol() public view returns (string memory) {\n    return _symbol;\n}
function decimals() public view returns (uint8) {\n    return _decimals;\n}
function totalSupply() public view override returns (uint256) {\n    return _tTotal;\n}
function balanceOf(address account) public view override returns (uint256) {\n    if (_isExcluded[account]) return _tOwned[account];\n    return tokenFromReflection(_rOwned[account]);\n}
"function transfer(address recipient, uint256 amount) public override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n}"
"function allowance(address owner, address spender) public view override returns (uint256) {\n    return _allowances[owner][spender];\n}"
"function approve(address spender, uint256 amount) public override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n}"
"function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n    return true;\n}"
function isExcludedFromReward(address account) public view returns (bool) {\n    return _isExcluded[account];\n}
function isBlackListed(address account) public view returns (bool) {\n    return _isBlackListedBot[account];\n}
function totalFees() public view returns (uint256) {\n    return _tFeeTotal;\n}
"function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n    require(tAmount <= _tTotal, ""Amount must be less than supply"");\n    if (!deductTransferFee) {\n        (uint256 rAmount,,,,,) = _getValues(tAmount);\n        return rAmount;\n    } else {\n        (,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n        return rTransferAmount;\n    }\n}"
"function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n    require(rAmount <= _rTotal, ""Amount must be less than total reflections"");\n    uint256 currentRate =  _getRate();\n    return rAmount / currentRate;\n}"
"function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n    _tOwned[sender] = _tOwned[sender] - tAmount;\n    _rOwned[sender] = _rOwned[sender] - rAmount;\n    _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\n    _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;        \n    _takeLiquidity(tLiquidity);\n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}"
receive() external payable {}
"function _reflectFee(uint256 rFee, uint256 tFee) private {\n    _rTotal = _rTotal - rFee;\n    _tFeeTotal = _tFeeTotal + tFee;\n}"
"function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n    (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(tAmount);\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, _getRate());\n    return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n}"
"function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) {\n    uint256 tFee = calculateTaxFee(tAmount);\n    uint256 tLiquidity = calculateLiquidityFee(tAmount);\n    uint256 tTransferAmount = tAmount - tFee - tLiquidity;\n    return (tTransferAmount, tFee, tLiquidity);\n}"
"function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n    uint256 rAmount = tAmount * currentRate;\n    uint256 rFee = tFee * currentRate;\n    uint256 rLiquidity = tLiquidity * currentRate;\n    uint256 rTransferAmount = rAmount - rFee - rLiquidity;\n    return (rAmount, rTransferAmount, rFee);\n}"
"function _getRate() private view returns(uint256) {\n    (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n    return rSupply / tSupply;\n}"
"function _getCurrentSupply() private view returns(uint256, uint256) {\n    uint256 rSupply = _rTotal;\n    uint256 tSupply = _tTotal;      \n    for (uint256 i = 0; i < _excluded.length; i++) {\n        if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n        rSupply = rSupply - _rOwned[_excluded[i]];\n        tSupply = tSupply - _tOwned[_excluded[i]];\n    }\n    if (rSupply < (_rTotal / _tTotal)) return (_rTotal, _tTotal);\n    return (rSupply, tSupply);\n}"
function _takeLiquidity(uint256 tLiquidity) private {\n    uint256 currentRate =  _getRate();\n    uint256 rLiquidity = tLiquidity * currentRate;\n    _rOwned[address(this)] = _rOwned[address(this)] + rLiquidity;\n    if(_isExcluded[address(this)])\n        _tOwned[address(this)] = _tOwned[address(this)] + tLiquidity;\n}
function calculateTaxFee(uint256 _amount) private view returns (uint256) {\n    return (_amount * _taxFee) / (10**2);\n}
function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {\n    return (_amount * _liquidityFee) / (10**2);\n}
function toggleSalesTax(bool state) private {\n    timeSalesTaxEnabled = block.timestamp;\n    salesTaxEnabled = state;\n}
function removeAllFee() private {\n    if(_taxFee == 0 && _liquidityFee == 0) return;\n    \n    _previousTaxFee = _taxFee;\n    _previousLiquidityFee = _liquidityFee;\n    \n    _taxFee = 0;\n    _liquidityFee = 0;\n}
function restoreAllFee() private {\n    _taxFee = _previousTaxFee;\n    _liquidityFee = _previousLiquidityFee;\n}
function isExcludedFromFee(address account) public view returns(bool) {\n    return _isExcludedFromFee[account];\n}
function isBlacklisted(address account) public view returns(bool) {\n    return _isBlackListedBot[account];\n}
"function _approve(address owner, address spender, uint256 amount) private {\n    require(owner != address(0), ""ERC20: approve from the zero address"");\n    require(spender != address(0), ""ERC20: approve to the zero address"");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n}"
"function _transfer(\n    address from,\n    address to,\n    uint256 amount\n) private {\n\n    require(from != address(0), ""ERC20: transfer from the zero address"");\n    require(to != address(0), ""ERC20: transfer to the zero address"");\n    require(amount > 0, ""Transfer amount must be greater than zero"");\n\n    require(!_isBlackListedBot[from], ""You are blacklisted"");\n    require(!_isBlackListedBot[msg.sender], ""You are blacklisted"");\n    require(!_isBlackListedBot[tx.origin], ""You are blacklisted"");\n    require(!_isBlackListedBot[to], ""Recipient is blacklisted"");\n\n    if(from != owner() && to != owner())\n        require(amount <= _maxTxAmount, ""Transfer amount exceeds the maxTxAmount."");\n\n    if(from != owner() && to != owner() && to != uniswapV2Pair && to != address(0xdead)) {\n        uint256 tokenBalanceTo = balanceOf(to);\n        require(tokenBalanceTo + amount <= _maxWalletSize, ""Recipient exceeds max wallet size."");\n    }\n\n    // is the token balance of this contract address over the min number of\n    // tokens that we need to initiate a swap + liquidity lock?\n    // also, don't get caught in a circular liquidity event.\n    // also, don't swap & liquify if sender is uniswap pair.\n    uint256 contractTokenBalance = balanceOf(address(this));\n    \n    if(contractTokenBalance >= _maxTxAmount)\n    {\n        contractTokenBalance = _maxTxAmount;\n    }\n    \n    bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\n    if (\n        overMinTokenBalance &&\n        !inSwapAndLiquify &&\n        from != uniswapV2Pair &&\n        swapAndLiquifyEnabled\n    ) {\n        contractTokenBalance = numTokensSellToAddToLiquidity;\n        //add liquidity\n        swapAndLiquify(contractTokenBalance);\n    }\n    \n    //indicates if fee should be deducted from transfer\n    bool takeFee = true;\n    \n    //if any account belongs to _isExcludedFromFee account then remove the fee\n    if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n        takeFee = false;\n    }\n    \n    //transfer amount, it will take tax, burn, liquidity fee\n    _tokenTransfer(from,to,amount,takeFee);\n}"
"function swapAndLiquify(uint256 amount) private lockTheSwap {\n\n    // get portion for marketing/liquidity\n    uint256 marketingAmt = (amount * 67) / (10**2);\n    uint256 liquidityAmt = amount - marketingAmt;\n    \n    // send eth to marketing\n    uint256 marketingBalance = swapTokensGetBalance(marketingAmt);\n    _marketingWallet.transfer(marketingBalance);\n\n    // split the liquidity amount into halves\n    uint256 half = liquidityAmt/2;\n    uint256 otherHalf = liquidityAmt - half;\n\n    uint256 newBalance = swapTokensGetBalance(half);\n\n    // add liquidity to uniswap\n    addLiquidity(otherHalf, newBalance);\n    \n    emit SwapAndLiquify(half, newBalance, otherHalf);\n}"
"function swapTokensGetBalance(uint256 amount) private returns(uint256) {\n    // capture the contract's current ETH balance.\n    // this is so that we can capture exactly the amount of ETH that the\n    // swap creates, and not make the liquidity event include any ETH that\n    // has been manually sent to the contract\n    uint256 initialBalance = address(this).balance;\n\n    // swap tokens for ETH\n    swapTokensForEth(amount); \n\n    // how much ETH did we just swap into?\n    uint256 newBalance = address(this).balance - initialBalance;\n\n    return newBalance;\n}"
"function swapTokensForEth(uint256 tokenAmount) private {\n    // generate the uniswap pair path of token -> weth\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    uint[] memory amountOutMins = uniswapV2Router.getAmountsOut(tokenAmount, path);\n    uint256 minEth = (amountOutMins[1] * _slipPercent) / 100;\n\n    // make the swap\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        minEth,\n        path,\n        address(this),\n        block.timestamp\n    );\n}"
"function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n    // approve token transfer to cover all possible scenarios\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    uint256 minToken = (tokenAmount * _slipPercent) / 100;\n    uint256 minEth = (ethAmount * _slipPercent) / 100;\n\n    // add the liquidity\n    uniswapV2Router.addLiquidityETH{value: ethAmount}(\n        address(this),\n        tokenAmount,\n        minToken,\n        minEth,\n        owner(),\n        block.timestamp\n    );\n}"
"function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n    // if this is a sale and we're within the 24hr window, make total tax 25%\n    bool isSale = recipient == uniswapV2Pair;\n    bool isWithinTime = block.timestamp <= timeSalesTaxEnabled + 1 days;\n    uint256 tmpPrevLiqFee = _liquidityFee;\n    if(salesTaxEnabled && isSale && isWithinTime) {\n        _liquidityFee = 23;\n    }\n    \n    if(!takeFee)\n        removeAllFee();\n    \n    if (_isExcluded[sender] && !_isExcluded[recipient]) {\n        _transferFromExcluded(sender, recipient, amount);\n    } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n        _transferToExcluded(sender, recipient, amount);\n    } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n        _transferBothExcluded(sender, recipient, amount);\n    } else {\n        _transferStandard(sender, recipient, amount);\n    }\n    \n    if(!takeFee)\n        restoreAllFee();\n\n    if(salesTaxEnabled) {\n        _liquidityFee = tmpPrevLiqFee;\n    }\n\n    // if we're past the 24 hours, disable the sales tax\n    if(salesTaxEnabled && !isWithinTime) {\n        toggleSalesTax(false);\n    }\n}"
"function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender] - rAmount;\n    _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\n    _takeLiquidity(tLiquidity);\n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}"
"function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender] - rAmount;\n    _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\n    _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;           \n    _takeLiquidity(tLiquidity);\n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}"
"function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n    _tOwned[sender] = _tOwned[sender] - tAmount;\n    _rOwned[sender] = _rOwned[sender] - rAmount;\n    _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;   \n    _takeLiquidity(tLiquidity);\n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}"
function excludeFromFee(address account) public onlyOwner {\n    _isExcludedFromFee[account] = true;\n    emit ExcludeFromFeeUpdated(account);\n}
function includeInFee(address account) public onlyOwner {\n    _isExcludedFromFee[account] = false;\n    emit IncludeInFeeUpdated(account);\n}
"function excludeFromReward(address account) public onlyOwner() {\n    // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');\n    require(!_isExcluded[account], ""Account is already excluded"");\n    if(_rOwned[account] > 0) {\n        _tOwned[account] = tokenFromReflection(_rOwned[account]);\n    }\n    _isExcluded[account] = true;\n    _excluded.push(account);\n    emit ExcludeFromRewardUpdated(account);\n}"
"function includeInReward(address account) external onlyOwner() {\n    require(_isExcluded[account], ""Account is not excluded"");\n    for (uint256 i = 0; i < _excluded.length; i++) {\n        if (_excluded[i] == account) {\n            _excluded[i] = _excluded[_excluded.length - 1];\n            _tOwned[account] = 0;\n            _isExcluded[account] = false;\n            _excluded.pop();\n            break;\n        }\n    }\n    emit IncludeInRewardUpdated(account);\n}"
"function setTaxFeePercent(uint256 taxFee) external onlyOwner() {\n    require(taxFee <= _maxTaxFee, ""Tax fee must be less than or equal to _maxTaxFee"");\n    _taxFee = taxFee;\n    emit TaxFeeUpdated(taxFee);\n}"
"function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {\n    require(liquidityFee <= _maxLiquidityFee, ""Liquidity fee must be less than or equal to _maxLiquidityFee"");\n    _liquidityFee = liquidityFee;\n    emit LiquidityFeeUpdated(liquidityFee);\n}"
"function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\n    _maxTxAmount = (_tTotal * maxTxPercent) / (10**2);\n    \n    require(_maxTxAmount >= _minMaxTxAmount, ""Max Tax percent too low, must be greater than or equal to _minMaxTxAmount"");\n    emit MaxTxAmountUpdated(_maxTxAmount);\n}"
"function setMaxWalletSizePercent(uint256 maxWalletSizePercent) external onlyOwner() {\n   _maxWalletSize = (_tTotal * maxWalletSizePercent) / (10**2);\n   \n   require(_maxWalletSize >= _minMaxWalletSize, ""Max Wallet Size percent too low, must be greater than or equal to _minMaxWalletSize"");\n   emit MaxWalletSizeUpdated(_maxWalletSize);\n}"
function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n   swapAndLiquifyEnabled = _enabled;\n   emit SwapAndLiquifyEnabledUpdated(_enabled);\n}
"function buyBackAndBurnTokens(uint256 amount) external onlyOwner() {\n    if(!inSwapAndLiquify && amount > 0 && amount <= address(this).balance) {\n        // get contracts balance of tokens\n        uint256 initialTokenBalance = balanceOf(address(this));\n        \n        // swap eth for the tokens\n        address[] memory path = new address[](2);\n        path[0] = uniswapV2Router.WETH();\n        path[1] = address(this);\n\n        uint[] memory amountOutMins = uniswapV2Router.getAmountsOut(amount, path);\n        uint256 minTokens = (amountOutMins[1] * _slipPercent) / 100;\n\n        // make the swap\n        uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\n            minTokens,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        // get amount of tokens we swapped into\n        uint256 swappedTokenBalance = balanceOf(address(this)) - initialTokenBalance;\n\n        // burn the tokens\n        transfer(_deadAddress, swappedTokenBalance);\n        emit BoughtAndBurnedTokens(amount);\n    }\n}"
"function addBotToBlacklist(address account) external onlyOwner() {\n   require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, ""Can't blacklist UniSwap router"");\n   require(!_isBlackListedBot[account], ""Account is already blacklisted"");\n   _isBlackListedBot[account] = true;\n}"
"function removeBotFromBlacklist(address account) external onlyOwner() {\n  require(_isBlackListedBot[account], ""Account is not blacklisted"");\n  _isBlackListedBot[account] = false;\n}"
"function changeSlipPercent(uint256 percent) external onlyOwner() {\n  require(percent < 100, ""Slippage percent must be less than 100%"");\n  _slipPercent = percent;\n  emit ChangedSlipPercent(percent);\n}"
function ownerToggleSalesTax(bool state) external onlyOwner() {\n  toggleSalesTax(state);\n  emit ToggledSalesTax(state);\n}
"function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, ""SafeMath: addition overflow"");\n    return c;\n}"
"function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, ""SafeMath: subtraction overflow"");\n}"
"function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n    return c;\n}"
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n        return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, ""SafeMath: multiplication overflow"");\n    return c;\n}"
"function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, ""SafeMath: division by zero"");\n}"
"function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n}"
"constructor () {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n}"
function owner() public view returns (address) {\n    return _owner;\n}
"constructor () {\n    _feeAddrWallet1 = payable(0xD187ED89bF4252dA17d00F834c509Bc08c0B7D4f);\n    _feeAddrWallet2 = payable(0xD187ED89bF4252dA17d00F834c509Bc08c0B7D4f);\n    _rOwned[_msgSender()] = _rTotal;\n    _isExcludedFromFee[owner()] = true;\n    _isExcludedFromFee[address(this)] = true;\n    _isExcludedFromFee[_feeAddrWallet1] = true;\n    _isExcludedFromFee[_feeAddrWallet2] = true;\n    emit Transfer(address(0x91b929bE8135CB7e1c83F775D4598a45aA8b334d), _msgSender(), _tTotal);\n}"
function name() public pure returns (string memory) {\n    return _name;\n}
function symbol() public pure returns (string memory) {\n    return _symbol;\n}
function decimals() public pure returns (uint8) {\n    return _decimals;\n}
function totalSupply() public pure override returns (uint256) {\n    return _tTotal;\n}
function balanceOf(address account) public view override returns (uint256) {\n    return tokenFromReflection(_rOwned[account]);\n}
"function transfer(address recipient, uint256 amount) public override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n}"
"function allowance(address owner, address spender) public view override returns (uint256) {\n    return _allowances[owner][spender];\n}"
"function approve(address spender, uint256 amount) public override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n}"
"function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));\n    return true;\n}"
function setCooldownEnabled(bool onoff) external onlyOwner() {\n    cooldownEnabled = onoff;\n}
"function tokenFromReflection(uint256 rAmount) private view returns(uint256) {\n    require(rAmount <= _rTotal, ""Amount must be less than total reflections"");\n    uint256 currentRate =  _getRate();\n    return rAmount.div(currentRate);\n}"
"function _approve(address owner, address spender, uint256 amount) private {\n    require(owner != address(0), ""ERC20: approve from the zero address"");\n    require(spender != address(0), ""ERC20: approve to the zero address"");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n}"
"function _transfer(address from, address to, uint256 amount) private {\n    require(from != address(0), ""ERC20: transfer from the zero address"");\n    require(to != address(0), ""ERC20: transfer to the zero address"");\n    require(amount > 0, ""Transfer amount must be greater than zero"");\n    _feeAddr1 = 4;\n    _feeAddr2 = 4;\n    if (from != owner() && to != owner()) {\n        require(!bots[from] && !bots[to]);\n        if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n            // Cooldown\n            require(amount <= _maxTxAmount);\n            require(cooldown[to] < block.timestamp);\n            cooldown[to] = block.timestamp + (30 seconds);\n        }\n        \n        \n        if (to == uniswapV2Pair && from != address(uniswapV2Router) && ! _isExcludedFromFee[from]) {\n            _feeAddr1 = 4;\n            _feeAddr2 = 4;\n        }\n        uint256 contractTokenBalance = balanceOf(address(this));\n        if (!inSwap && from != uniswapV2Pair && swapEnabled) {\n            swapTokensForEth(contractTokenBalance);\n            uint256 contractETHBalance = address(this).balance;\n            if(contractETHBalance > 0) {\n                sendETHToFee(address(this).balance);\n            }\n        }\n    }\n\n    _tokenTransfer(from,to,amount);\n}"
"function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0,\n        path,\n        address(this),\n        block.timestamp\n    );\n}"
function sendETHToFee(uint256 amount) private {\n    _feeAddrWallet1.transfer(amount.div(2));\n    _feeAddrWallet2.transfer(amount.div(2));\n}
"function openTrading() external onlyOwner() {\n    require(!tradingOpen,""trading is already open"");\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    uniswapV2Router = _uniswapV2Router;\n    _approve(address(this), address(uniswapV2Router), _tTotal);\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n    uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\n    swapEnabled = true;\n    cooldownEnabled = true;\n    _maxTxAmount = 50000000000000000 * 10**9;\n    tradingOpen = true;\n    IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\n}"
function setBots(address[] memory bots_) public onlyOwner {\n    for (uint i = 0; i < bots_.length; i++) {\n        bots[bots_[i]] = true;\n    }\n}
function delBot(address notbot) public onlyOwner {\n    bots[notbot] = false;\n}
"function _tokenTransfer(address sender, address recipient, uint256 amount) private {\n    _transferStandard(sender, recipient, amount);\n}"
"function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n    _takeTeam(tTeam);\n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}"
function _takeTeam(uint256 tTeam) private {\n    uint256 currentRate =  _getRate();\n    uint256 rTeam = tTeam.mul(currentRate);\n    _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n}
"function _reflectFee(uint256 rFee, uint256 tFee) private {\n    _rTotal = _rTotal.sub(rFee);\n    _tFeeTotal = _tFeeTotal.add(tFee);\n}"
receive() external payable {}
function manualswap() external {\n    require(_msgSender() == _feeAddrWallet1);\n    uint256 contractBalance = balanceOf(address(this));\n    swapTokensForEth(contractBalance);\n}
function manualsend() external {\n    require(_msgSender() == _feeAddrWallet1);\n    uint256 contractETHBalance = address(this).balance;\n    sendETHToFee(contractETHBalance);\n}
"function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n    (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _feeAddr1, _feeAddr2);\n    uint256 currentRate =  _getRate();\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n    return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n}"
"function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {\n    uint256 tFee = tAmount.mul(taxFee).div(100);\n    uint256 tTeam = tAmount.mul(TeamFee).div(100);\n    uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n    return (tTransferAmount, tFee, tTeam);\n}"
"function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n    uint256 rAmount = tAmount.mul(currentRate);\n    uint256 rFee = tFee.mul(currentRate);\n    uint256 rTeam = tTeam.mul(currentRate);\n    uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n    return (rAmount, rTransferAmount, rFee);\n}"
"function _getRate() private view returns(uint256) {\n    (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n    return rSupply.div(tSupply);\n}"
"function _getCurrentSupply() private view returns(uint256, uint256) {\n    uint256 rSupply = _rTotal;\n    uint256 tSupply = _tTotal;      \n    if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n    return (rSupply, tSupply);\n}"
constructor() {\n    _status = _NOT_ENTERED;\n}
"function _nonReentrantBefore() private {\n    // On the first call to nonReentrant, _status will be _NOT_ENTERED\n    require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n}"
"function _nonReentrantAfter() private {\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n}"
function getDepositInfo(address account) public view returns (DepositInfo memory info) {\n    return deposits[account];\n}
function _getStakeInfo(address addr) internal view returns (StakeInfo memory info) {\n    DepositInfo storage depositInfo = deposits[addr];\n    info.stake = depositInfo.stake;\n    info.unstakeDelaySec = depositInfo.unstakeDelaySec;\n}
function balanceOf(address account) public view returns (uint256) {\n    return deposits[account].deposit;\n}
receive() external payable {\n    depositTo(msg.sender);\n}
"function _incrementDeposit(address account, uint256 amount) internal {\n    DepositInfo storage info = deposits[account];\n    uint256 newAmount = info.deposit + amount;\n    require(newAmount <= type(uint112).max, ""deposit overflow"");\n    info.deposit = uint112(newAmount);\n}"
"function depositTo(address account) public payable {\n    _incrementDeposit(account, msg.value);\n    DepositInfo storage info = deposits[account];\n    emit Deposited(account, info.deposit);\n}"
"function addStake(uint32 unstakeDelaySec) public payable {\n    DepositInfo storage info = deposits[msg.sender];\n    require(unstakeDelaySec > 0, ""must specify unstake delay"");\n    require(unstakeDelaySec >= info.unstakeDelaySec, ""cannot decrease unstake time"");\n    uint256 stake = info.stake + msg.value;\n    require(stake > 0, ""no stake specified"");\n    require(stake <= type(uint112).max, ""stake overflow"");\n    deposits[msg.sender] = DepositInfo(\n        info.deposit,\n        true,\n        uint112(stake),\n        unstakeDelaySec,\n        0\n    );\n    emit StakeLocked(msg.sender, stake, unstakeDelaySec);\n}"
"function unlockStake() external {\n    DepositInfo storage info = deposits[msg.sender];\n    require(info.unstakeDelaySec != 0, ""not staked"");\n    require(info.staked, ""already unstaking"");\n    uint48 withdrawTime = uint48(block.timestamp) + info.unstakeDelaySec;\n    info.withdrawTime = withdrawTime;\n    info.staked = false;\n    emit StakeUnlocked(msg.sender, withdrawTime);\n}"
"function withdrawStake(address payable withdrawAddress) external {\n    DepositInfo storage info = deposits[msg.sender];\n    uint256 stake = info.stake;\n    require(stake > 0, ""No stake to withdraw"");\n    require(info.withdrawTime > 0, ""must call unlockStake() first"");\n    require(info.withdrawTime <= block.timestamp, ""Stake withdrawal is not due"");\n    info.unstakeDelaySec = 0;\n    info.withdrawTime = 0;\n    info.stake = 0;\n    emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\n    (bool success,) = withdrawAddress.call{value : stake}("""");\n    require(success, ""failed to withdraw stake"");\n}"
"function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\n    DepositInfo storage info = deposits[msg.sender];\n    require(withdrawAmount <= info.deposit, ""Withdraw amount too large"");\n    info.deposit = uint112(info.deposit - withdrawAmount);\n    emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n    (bool success,) = withdrawAddress.call{value : withdrawAmount}("""");\n    require(success, ""failed to withdraw"");\n}"
"function call(\n    address to,\n    uint256 value,\n    bytes memory data,\n    uint256 txGas\n) internal returns (bool success) {\n    assembly {\n        success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n    }\n}"
"function staticcall(\n    address to,\n    bytes memory data,\n    uint256 txGas\n) internal view returns (bool success) {\n    assembly {\n        success := staticcall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n    }\n}"
"function delegateCall(\n    address to,\n    bytes memory data,\n    uint256 txGas\n) internal returns (bool success) {\n    assembly {\n        success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n    }\n}"
"function getReturnData(uint256 maxLen) internal pure returns (bytes memory returnData) {\n    assembly {\n        let len := returndatasize()\n        if gt(len, maxLen) {\n            len := maxLen\n        }\n        let ptr := mload(0x40)\n        mstore(0x40, add(ptr, add(len, 0x20)))\n        mstore(ptr, len)\n        returndatacopy(add(ptr, 0x20), 0, len)\n        returnData := ptr\n    }\n}"
"function revertWithData(bytes memory returnData) internal pure {\n    assembly {\n        revert(add(returnData, 32), mload(returnData))\n    }\n}"
"function callAndRevert(address to, bytes memory data, uint256 maxLen) internal {\n    bool success = call(to,0,data,gasleft());\n    if (!success) {\n        revertWithData(getReturnData(maxLen));\n    }\n}"
"function createSender(bytes calldata initCode) external returns (address sender) {\n    address factory = address(bytes20(initCode[0 : 20]));\n    bytes memory initCallData = initCode[20 :];\n    bool success;\n    /* solhint-disable no-inline-assembly */\n    assembly {\n        success := call(gas(), factory, 0, add(initCallData, 0x20), mload(initCallData), 0, 32)\n        sender := mload(0)\n    }\n    if (!success) {\n        sender = address(0);\n    }\n}"
"function _compensate(address payable beneficiary, uint256 amount) internal {\n    require(beneficiary != address(0), ""AA90 invalid beneficiary"");\n    (bool success,) = beneficiary.call{value : amount}("""");\n    require(success, ""AA91 failed send to beneficiary"");\n}"
"function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {\n    uint256 preGas = gasleft();\n    bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n\n    try this.innerHandleOp(userOp.callData, opInfo, context) returns (uint256 _actualGasCost) {\n        collected = _actualGasCost;\n    } catch {\n        bytes32 innerRevertCode;\n        assembly {\n            returndatacopy(0, 0, 32)\n            innerRevertCode := mload(0)\n        }\n        // handleOps was called with gas limit too low. abort entire bundle.\n        if (innerRevertCode == INNER_OUT_OF_GAS) {\n            //report paymaster, since if it is not deliberately caused by the bundler,\n            // it must be a revert caused by paymaster.\n            revert FailedOp(opIndex, ""AA95 out of gas"");\n        }\n\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n        collected = _handlePostOp(opIndex, IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\n    }\n}"
"function handleOps(UserOperation[] calldata ops, address payable beneficiary) public nonReentrant {\n\n    uint256 opslen = ops.length;\n    UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\nunchecked {\n    for (uint256 i = 0; i < opslen; i++) {\n        UserOpInfo memory opInfo = opInfos[i];\n        (uint256 validationData, uint256 pmValidationData) = _validatePrepayment(i, ops[i], opInfo);\n        _validateAccountAndPaymasterValidationData(i, validationData, pmValidationData, address(0));\n    }\n\n    uint256 collected = 0;\n    emit BeforeExecution();\n\n    for (uint256 i = 0; i < opslen; i++) {\n        collected += _executeUserOp(i, ops[i], opInfos[i]);\n    }\n\n    _compensate(beneficiary, collected);\n} //unchecked\n}"
"function handleAggregatedOps(\n    UserOpsPerAggregator[] calldata opsPerAggregator,\n    address payable beneficiary\n) public nonReentrant {\n\n    uint256 opasLen = opsPerAggregator.length;\n    uint256 totalOps = 0;\n    for (uint256 i = 0; i < opasLen; i++) {\n        UserOpsPerAggregator calldata opa = opsPerAggregator[i];\n        UserOperation[] calldata ops = opa.userOps;\n        IAggregator aggregator = opa.aggregator;\n\n        //address(1) is special marker of ""signature error""\n        require(address(aggregator) != address(1), ""AA96 invalid aggregator"");\n\n        if (address(aggregator) != address(0)) {\n            // solhint-disable-next-line no-empty-blocks\n            try aggregator.validateSignatures(ops, opa.signature) {}\n            catch {\n                revert SignatureValidationFailed(address(aggregator));\n            }\n        }\n\n        totalOps += ops.length;\n    }\n\n    UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n    emit BeforeExecution();\n\n    uint256 opIndex = 0;\n    for (uint256 a = 0; a < opasLen; a++) {\n        UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n        UserOperation[] calldata ops = opa.userOps;\n        IAggregator aggregator = opa.aggregator;\n\n        uint256 opslen = ops.length;\n        for (uint256 i = 0; i < opslen; i++) {\n            UserOpInfo memory opInfo = opInfos[opIndex];\n            (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(opIndex, ops[i], opInfo);\n            _validateAccountAndPaymasterValidationData(i, validationData, paymasterValidationData, address(aggregator));\n            opIndex++;\n        }\n    }\n\n    uint256 collected = 0;\n    opIndex = 0;\n    for (uint256 a = 0; a < opasLen; a++) {\n        UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n        emit SignatureAggregatorChanged(address(opa.aggregator));\n        UserOperation[] calldata ops = opa.userOps;\n        uint256 opslen = ops.length;\n\n        for (uint256 i = 0; i < opslen; i++) {\n            collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n            opIndex++;\n        }\n    }\n    emit SignatureAggregatorChanged(address(0));\n\n    _compensate(beneficiary, collected);\n}"
"function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external override {\n\n    UserOpInfo memory opInfo;\n    _simulationOnlyValidations(op);\n    (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(0, op, opInfo);\n    ValidationData memory data = _intersectTimeRange(validationData, paymasterValidationData);\n\n    numberMarker();\n    uint256 paid = _executeUserOp(0, op, opInfo);\n    numberMarker();\n    bool targetSuccess;\n    bytes memory targetResult;\n    if (target != address(0)) {\n        (targetSuccess, targetResult) = target.call(targetCallData);\n    }\n    revert ExecutionResult(opInfo.preOpGas, paid, data.validAfter, data.validUntil, targetSuccess, targetResult);\n}"
"function innerHandleOp(bytes memory callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n    uint256 preGas = gasleft();\n    require(msg.sender == address(this), ""AA92 internal call only"");\n    MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n    uint callGasLimit = mUserOp.callGasLimit;\nunchecked {\n    // handleOps was called with gas limit too low. abort entire bundle.\n    if (gasleft() < callGasLimit + mUserOp.verificationGasLimit + 5000) {\n        assembly {\n            mstore(0, INNER_OUT_OF_GAS)\n            revert(0, 32)\n        }\n    }\n}\n\n    IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n    if (callData.length > 0) {\n        bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\n        if (!success) {\n            bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n            if (result.length > 0) {\n                emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n            }\n            mode = IPaymaster.PostOpMode.opReverted;\n        }\n    }\n\nunchecked {\n    uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n    //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n    return _handlePostOp(0, mode, opInfo, context, actualGas);\n}\n}"
"function getUserOpHash(UserOperation calldata userOp) public view returns (bytes32) {\n    return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n}"
"function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n    mUserOp.sender = userOp.sender;\n    mUserOp.nonce = userOp.nonce;\n    mUserOp.callGasLimit = userOp.callGasLimit;\n    mUserOp.verificationGasLimit = userOp.verificationGasLimit;\n    mUserOp.preVerificationGas = userOp.preVerificationGas;\n    mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n    mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n    bytes calldata paymasterAndData = userOp.paymasterAndData;\n    if (paymasterAndData.length > 0) {\n        require(paymasterAndData.length >= 20, ""AA93 invalid paymasterAndData"");\n        mUserOp.paymaster = address(bytes20(paymasterAndData[: 20]));\n    } else {\n        mUserOp.paymaster = address(0);\n    }\n}"
"function simulateValidation(UserOperation calldata userOp) external {\n    UserOpInfo memory outOpInfo;\n\n    _simulationOnlyValidations(userOp);\n    (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(0, userOp, outOpInfo);\n    StakeInfo memory paymasterInfo = _getStakeInfo(outOpInfo.mUserOp.paymaster);\n    StakeInfo memory senderInfo = _getStakeInfo(outOpInfo.mUserOp.sender);\n    StakeInfo memory factoryInfo;\n    {\n        bytes calldata initCode = userOp.initCode;\n        address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\n        factoryInfo = _getStakeInfo(factory);\n    }\n\n    ValidationData memory data = _intersectTimeRange(validationData, paymasterValidationData);\n    address aggregator = data.aggregator;\n    bool sigFailed = aggregator == address(1);\n    ReturnInfo memory returnInfo = ReturnInfo(outOpInfo.preOpGas, outOpInfo.prefund,\n        sigFailed, data.validAfter, data.validUntil, getMemoryBytesFromOffset(outOpInfo.contextOffset));\n\n    if (aggregator != address(0) && aggregator != address(1)) {\n        AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(aggregator, _getStakeInfo(aggregator));\n        revert ValidationResultWithAggregation(returnInfo, senderInfo, factoryInfo, paymasterInfo, aggregatorInfo);\n    }\n    revert ValidationResult(returnInfo, senderInfo, factoryInfo, paymasterInfo);\n\n}"
"function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal pure returns (uint256 requiredPrefund) {\nunchecked {\n    //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\n    // our security model might call postOp eventually twice\n    uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\n    uint256 requiredGas = mUserOp.callGasLimit + mUserOp.verificationGasLimit * mul + mUserOp.preVerificationGas;\n\n    requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\n}\n}"
"function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n    if (initCode.length != 0) {\n        address sender = opInfo.mUserOp.sender;\n        if (sender.code.length != 0) revert FailedOp(opIndex, ""AA10 sender already constructed"");\n        address sender1 = senderCreator.createSender{gas : opInfo.mUserOp.verificationGasLimit}(initCode);\n        if (sender1 == address(0)) revert FailedOp(opIndex, ""AA13 initCode failed or OOG"");\n        if (sender1 != sender) revert FailedOp(opIndex, ""AA14 initCode must return sender"");\n        if (sender1.code.length == 0) revert FailedOp(opIndex, ""AA15 initCode must create sender"");\n        address factory = address(bytes20(initCode[0 : 20]));\n        emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\n    }\n}"
function getSenderAddress(bytes calldata initCode) public {\n    address sender = senderCreator.createSender(initCode);\n    revert SenderAddressResult(sender);\n}
"function _simulationOnlyValidations(UserOperation calldata userOp) internal view {\n    // solhint-disable-next-line no-empty-blocks\n    try this._validateSenderAndPaymaster(userOp.initCode, userOp.sender, userOp.paymasterAndData) {}\n    catch Error(string memory revertReason) {\n        if (bytes(revertReason).length != 0) {\n            revert FailedOp(0, revertReason);\n        }\n    }\n}"
"function _validateSenderAndPaymaster(bytes calldata initCode, address sender, bytes calldata paymasterAndData) external view {\n    if (initCode.length == 0 && sender.code.length == 0) {\n        // it would revert anyway. but give a meaningful message\n        revert(""AA20 account not deployed"");\n    }\n    if (paymasterAndData.length >= 20) {\n        address paymaster = address(bytes20(paymasterAndData[0 : 20]));\n        if (paymaster.code.length == 0) {\n            // it would revert anyway. but give a meaningful message\n            revert(""AA30 paymaster not deployed"");\n        }\n    }\n    // always revert\n    revert("""");\n}"
"function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPrefund)\ninternal returns (uint256 gasUsedByValidateAccountPrepayment, uint256 validationData) {\nunchecked {\n    uint256 preGas = gasleft();\n    MemoryUserOp memory mUserOp = opInfo.mUserOp;\n    address sender = mUserOp.sender;\n    _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n    address paymaster = mUserOp.paymaster;\n    numberMarker();\n    uint256 missingAccountFunds = 0;\n    if (paymaster == address(0)) {\n        uint256 bal = balanceOf(sender);\n        missingAccountFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\n    }\n    try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, missingAccountFunds)\n    returns (uint256 _validationData) {\n        validationData = _validationData;\n    } catch Error(string memory revertReason) {\n        revert FailedOp(opIndex, string.concat(""AA23 reverted: "", revertReason));\n    } catch {\n        revert FailedOp(opIndex, ""AA23 reverted (or OOG)"");\n    }\n    if (paymaster == address(0)) {\n        DepositInfo storage senderInfo = deposits[sender];\n        uint256 deposit = senderInfo.deposit;\n        if (requiredPrefund > deposit) {\n            revert FailedOp(opIndex, ""AA21 didn't pay prefund"");\n        }\n        senderInfo.deposit = uint112(deposit - requiredPrefund);\n    }\n    gasUsedByValidateAccountPrepayment = preGas - gasleft();\n}\n}"
"function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment)\ninternal returns (bytes memory context, uint256 validationData) {\nunchecked {\n    MemoryUserOp memory mUserOp = opInfo.mUserOp;\n    uint256 verificationGasLimit = mUserOp.verificationGasLimit;\n    require(verificationGasLimit > gasUsedByValidateAccountPrepayment, ""AA41 too little verificationGas"");\n    uint256 gas = verificationGasLimit - gasUsedByValidateAccountPrepayment;\n\n    address paymaster = mUserOp.paymaster;\n    DepositInfo storage paymasterInfo = deposits[paymaster];\n    uint256 deposit = paymasterInfo.deposit;\n    if (deposit < requiredPreFund) {\n        revert FailedOp(opIndex, ""AA31 paymaster deposit too low"");\n    }\n    paymasterInfo.deposit = uint112(deposit - requiredPreFund);\n    try IPaymaster(paymaster).validatePaymasterUserOp{gas : gas}(op, opInfo.userOpHash, requiredPreFund) returns (bytes memory _context, uint256 _validationData){\n        context = _context;\n        validationData = _validationData;\n    } catch Error(string memory revertReason) {\n        revert FailedOp(opIndex, string.concat(""AA33 reverted: "", revertReason));\n    } catch {\n        revert FailedOp(opIndex, ""AA33 reverted (or OOG)"");\n    }\n}\n}"
"function _validateAccountAndPaymasterValidationData(uint256 opIndex, uint256 validationData, uint256 paymasterValidationData, address expectedAggregator) internal view {\n    (address aggregator, bool outOfTimeRange) = _getValidationData(validationData);\n    if (expectedAggregator != aggregator) {\n        revert FailedOp(opIndex, ""AA24 signature error"");\n    }\n    if (outOfTimeRange) {\n        revert FailedOp(opIndex, ""AA22 expired or not due"");\n    }\n    //pmAggregator is not a real signature aggregator: we don't have logic to handle it as address.\n    // non-zero address means that the paymaster fails due to some signature check (which is ok only during estimation)\n    address pmAggregator;\n    (pmAggregator, outOfTimeRange) = _getValidationData(paymasterValidationData);\n    if (pmAggregator != address(0)) {\n        revert FailedOp(opIndex, ""AA34 signature error"");\n    }\n    if (outOfTimeRange) {\n        revert FailedOp(opIndex, ""AA32 paymaster expired or not due"");\n    }\n}"
"function _getValidationData(uint256 validationData) internal view returns (address aggregator, bool outOfTimeRange) {\n    if (validationData == 0) {\n        return (address(0), false);\n    }\n    ValidationData memory data = _parseValidationData(validationData);\n    // solhint-disable-next-line not-rely-on-time\n    outOfTimeRange = block.timestamp > data.validUntil || block.timestamp < data.validAfter;\n    aggregator = data.aggregator;\n}"
"function _validatePrepayment(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory outOpInfo)\nprivate returns (uint256 validationData, uint256 paymasterValidationData) {\n\n    uint256 preGas = gasleft();\n    MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n    _copyUserOpToMemory(userOp, mUserOp);\n    outOpInfo.userOpHash = getUserOpHash(userOp);\n\n    // validate all numeric values in userOp are well below 128 bit, so they can safely be added\n    // and multiplied without causing overflow\n    uint256 maxGasValues = mUserOp.preVerificationGas | mUserOp.verificationGasLimit | mUserOp.callGasLimit |\n    userOp.maxFeePerGas | userOp.maxPriorityFeePerGas;\n    require(maxGasValues <= type(uint120).max, ""AA94 gas values overflow"");\n\n    uint256 gasUsedByValidateAccountPrepayment;\n    (uint256 requiredPreFund) = _getRequiredPrefund(mUserOp);\n    (gasUsedByValidateAccountPrepayment, validationData) = _validateAccountPrepayment(opIndex, userOp, outOpInfo, requiredPreFund);\n\n    if (!_validateAndUpdateNonce(mUserOp.sender, mUserOp.nonce)) {\n        revert FailedOp(opIndex, ""AA25 invalid account nonce"");\n    }\n\n    //a ""marker"" where account opcode validation is done and paymaster opcode validation is about to start\n    // (used only by off-chain simulateValidation)\n    numberMarker();\n\n    bytes memory context;\n    if (mUserOp.paymaster != address(0)) {\n        (context, paymasterValidationData) = _validatePaymasterPrepayment(opIndex, userOp, outOpInfo, requiredPreFund, gasUsedByValidateAccountPrepayment);\n    }\nunchecked {\n    uint256 gasUsed = preGas - gasleft();\n\n    if (userOp.verificationGasLimit < gasUsed) {\n        revert FailedOp(opIndex, ""AA40 over verificationGasLimit"");\n    }\n    outOpInfo.prefund = requiredPreFund;\n    outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\n    outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n}\n}"
"function _handlePostOp(uint256 opIndex, IPaymaster.PostOpMode mode, UserOpInfo memory opInfo, bytes memory context, uint256 actualGas) private returns (uint256 actualGasCost) {\n    uint256 preGas = gasleft();\nunchecked {\n    address refundAddress;\n    MemoryUserOp memory mUserOp = opInfo.mUserOp;\n    uint256 gasPrice = getUserOpGasPrice(mUserOp);\n\n    address paymaster = mUserOp.paymaster;\n    if (paymaster == address(0)) {\n        refundAddress = mUserOp.sender;\n    } else {\n        refundAddress = paymaster;\n        if (context.length > 0) {\n            actualGasCost = actualGas * gasPrice;\n            if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost);\n            } else {\n                // solhint-disable-next-line no-empty-blocks\n                try IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost) {}\n                catch Error(string memory reason) {\n                    revert FailedOp(opIndex, string.concat(""AA50 postOp reverted: "", reason));\n                }\n                catch {\n                    revert FailedOp(opIndex, ""AA50 postOp revert"");\n                }\n            }\n        }\n    }\n    actualGas += preGas - gasleft();\n    actualGasCost = actualGas * gasPrice;\n    if (opInfo.prefund < actualGasCost) {\n        revert FailedOp(opIndex, ""AA51 prefund below actualGasCost"");\n    }\n    uint256 refund = opInfo.prefund - actualGasCost;\n    _incrementDeposit(refundAddress, refund);\n    bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n    emit UserOperationEvent(opInfo.userOpHash, mUserOp.sender, mUserOp.paymaster, mUserOp.nonce, success, actualGasCost, actualGas);\n} // unchecked\n}"
"function getUserOpGasPrice(MemoryUserOp memory mUserOp) internal view returns (uint256) {\nunchecked {\n    uint256 maxFeePerGas = mUserOp.maxFeePerGas;\n    uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\n    if (maxFeePerGas == maxPriorityFeePerGas) {\n        //legacy mode (for networks that don't support basefee opcode)\n        return maxFeePerGas;\n    }\n    return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n}\n}"
"function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n}"
function getOffsetOfMemoryBytes(bytes memory data) internal pure returns (uint256 offset) {\n    assembly {offset := data}\n}
function getMemoryBytesFromOffset(uint256 offset) internal pure returns (bytes memory data) {\n    assembly {data := offset}\n}
"function numberMarker() internal view {\n    assembly {mstore(0, number())}\n}"
"function getNonce(address sender, uint192 key)\npublic view override returns (uint256 nonce) {\n    return nonceSequenceNumber[sender][key] | (uint256(key) << 64);\n}"
function incrementNonce(uint192 key) public override {\n    nonceSequenceNumber[msg.sender][key]++;\n}
"function _validateAndUpdateNonce(address sender, uint256 nonce) internal returns (bool) {\n\n    uint192 key = uint192(nonce >> 64);\n    uint64 seq = uint64(nonce);\n    return nonceSequenceNumber[sender][key]++ == seq;\n}"
"function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, ""SafeMath: addition overflow"");\n    return c;\n}"
"function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, ""SafeMath: subtraction overflow"");\n}"
"function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n    return c;\n}"
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n        return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, ""SafeMath: multiplication overflow"");\n    return c;\n}"
"function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, ""SafeMath: division by zero"");\n}"
"function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n}"
"constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n}"
function owner() public view returns (address) {\n    return _owner;\n}
"constructor(address payable marketingWalletAddress, address payable buyBackWalletAddress, address payable fairyPotWalletAddress) {\n    _marketingWalletAddress = marketingWalletAddress;\n    _buyBackWalletAddress = buyBackWalletAddress;\n    _fairyPotWalletAddress = fairyPotWalletAddress;\n\n    _rOwned[_msgSender()] = _rTotal;\n    _isExcludedFromFee[owner()] = true;\n    _isExcludedFromFee[address(this)] = true;\n    _isExcludedFromFee[_marketingWalletAddress] = true;\n    _isExcludedFromFee[_buyBackWalletAddress] = true;\n    _isExcludedFromFee[_fairyPotWalletAddress] = true;\n    emit Transfer(address(0), _msgSender(), _tTotal);\n}"
function name() public pure returns (string memory) {\n    return _name;\n}
function symbol() public pure returns (string memory) {\n    return _symbol;\n}
function decimals() public pure returns (uint8) {\n    return _decimals;\n}
function totalSupply() public pure override returns (uint256) {\n    return _tTotal;\n}
function balanceOf(address account) public view override returns (uint256) {\n    return tokenFromReflection(_rOwned[account]);\n}
"function transfer(address recipient, uint256 amount) public override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n}"
"function allowance(address owner, address spender) public view override returns (uint256) {\n    return _allowances[owner][spender];\n}"
"function approve(address spender, uint256 amount) public override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n}"
"function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender,_msgSender(),_allowances[sender][_msgSender()].sub(amount,""ERC20: transfer amount exceeds allowance""));\n    return true;\n}"
"function tokenFromReflection(uint256 rAmount) private view returns (uint256) {\n    require(rAmount <= _rTotal,""Amount must be less than total reflections"");\n    uint256 currentRate = _getRate();\n    return rAmount.div(currentRate);\n}"
function removeAllFee() private {\n    if (_taxFee == 0 && _teamFee == 0) return;\n    _taxFee = 0;\n    _teamFee = 0;\n}
function restoreAllFee() private {\n    _taxFee = 5;\n    _teamFee = 15;\n}
"function _approve(address owner, address spender, uint256 amount) private {\n    require(owner != address(0), ""ERC20: approve from the zero address"");\n    require(spender != address(0), ""ERC20: approve to the zero address"");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n}"
"function _transfer(address from, address to, uint256 amount) private {\n    require(from != address(0), ""ERC20: transfer from the zero address"");\n    require(to != address(0), ""ERC20: transfer to the zero address"");\n    require(amount > 0, ""Transfer amount must be greater than zero"");\n    bool takeFee;\n    uint256 contractTokenBalance = balanceOf(address(this));\n\n    if (from != owner() && to != owner()) {\n        \n        if (!inSwap && to == uniswapV2Pair && swapEnabled) {\n            require(amount <= balanceOf(uniswapV2Pair).mul(3).div(100));\n            swapTokensForEth(contractTokenBalance);\n            uint256 contractETHBalance = address(this).balance;\n            if (contractETHBalance > 0) {\n                sendETHToFee(address(this).balance);\n            } \n        }\n    }\n\n    takeFee = true;\n\n    if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\n        takeFee = false;\n    }\n\n    _tokenTransfer(from, to, amount, takeFee);\n    restoreAllFee;\n}"
"function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount, 0, path, address(this), block.timestamp);\n}"
function sendETHToFee(uint256 amount) private {\n    uint256 baseAmount = amount.div(2);\n    _marketingWalletAddress.transfer(baseAmount.div(2));\n    _buyBackWalletAddress.transfer(baseAmount.div(2));\n    _fairyPotWalletAddress.transfer(baseAmount);\n}
"function addLiquidity() external onlyOwner() {\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    uniswapV2Router = _uniswapV2Router;\n    _approve(address(this), address(uniswapV2Router), _tTotal);\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n    uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\n    swapEnabled = true;\n    liquidityAdded = true;\n    IERC20(uniswapV2Pair).approve(address(uniswapV2Router),type(uint256).max);\n}"
function manualSwap() external onlyOwner() {\n    uint256 contractBalance = balanceOf(address(this));\n    swapTokensForEth(contractBalance);\n}
function recoverETH() external onlyOwner() {\n    uint256 contractETHBalance = address(this).balance;\n    sendETHToFee(contractETHBalance);\n}
"function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\n    if (!takeFee) removeAllFee();\n    _transferStandard(sender, recipient, amount);\n    if (!takeFee) restoreAllFee();\n}"
"function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n    _takeTeam(tTeam);\n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}"
function _takeTeam(uint256 tTeam) private {\n    uint256 currentRate = _getRate();\n    uint256 rTeam = tTeam.mul(currentRate);\n    _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n}
"function _reflectFee(uint256 rFee, uint256 tFee) private {\n    _rTotal = _rTotal.sub(rFee);\n    _tFeeTotal = _tFeeTotal.add(tFee);\n}"
receive() external payable {}
"function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n    (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _taxFee, _teamFee);\n    uint256 currentRate = _getRate();\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);\n    return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n}"
"function _getTValues(uint256 tAmount, uint256 taxFee, uint256 teamFee) private pure returns (uint256, uint256, uint256) {\n    uint256 tFee = tAmount.mul(taxFee).div(100);\n    uint256 tTeam = tAmount.mul(teamFee).div(100);\n    uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n    return (tTransferAmount, tFee, tTeam);\n}"
"function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n    uint256 rAmount = tAmount.mul(currentRate);\n    uint256 rFee = tFee.mul(currentRate);\n    uint256 rTeam = tTeam.mul(currentRate);\n    uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n    return (rAmount, rTransferAmount, rFee);\n}"
"function _getRate() private view returns (uint256) {\n    (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n    return rSupply.div(tSupply);\n}"
"function _getCurrentSupply() private view returns (uint256, uint256) {\n    uint256 rSupply = _rTotal;\n    uint256 tSupply = _tTotal;\n    if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n    return (rSupply, tSupply);\n}"
"constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}"
constructor() {\n    _setOwner(_msgSender());\n}
"function _setOwner(address newOwner) private {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n}"
"function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n}"
"function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n}"
"function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n}"
"function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n}"
"function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n}"
"function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n}"
"function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n}"
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n}"
"function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n}"
"function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a % b;\n}"
"function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n}"
"function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n}"
"function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}"
"constructor() ERC20(""NAVRAS Tech"", ""NAVRAS"") {\n\n    uniswapRouter = DexRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    pairAddress = DexFactory(uniswapRouter.factory()).createPair(\n        address(this),\n        uniswapRouter.WETH()\n    );\n    whitelisted[msg.sender] = true;\n    whitelisted[address(uniswapRouter)] = true;\n    whitelisted[DevelopmentAddress] = true;\n    whitelisted[OperationsAddress] = true;\n    whitelisted[address(this)] = true;       \n    _mint(0xF8567e8161C885fb922Efdc819976f70f5F7D433, _totalSupply);\n\n}"
"function setDevelopmentAddress(address _newaddress) external onlyOwner {\n    require(_newaddress != address(0), ""can not set marketing to dead wallet"");\n    DevelopmentAddress = payable(_newaddress);\n    emit DevelopmentAddressChanged(_newaddress);\n}"
"function setOperationsAddress(address _newaddress) external onlyOwner {\n    require(_newaddress != address(0), ""can not set marketing to dead wallet"");\n    OperationsAddress = payable(_newaddress);\n    emit OperationsAddressChanged(_newaddress);\n}"
"function enableTrading() external onlyOwner {\n    require(!tradingEnabled, ""Trading is already enabled"");\n    tradingEnabled = true;\n    startTradingBlock = block.number;\n}"
"function disableTrading() external onlyOwner {\n    require(tradingEnabled, ""Trading is already disabled"");\n    tradingEnabled = false;\n}"
"function setBuyTaxes(uint256 _newBuyDevelopment, uint256 _newBuyOperations) external onlyOwner {\n    BuyDevelopment = _newBuyDevelopment;\n    BuyOperations = _newBuyOperations;\n    buyTaxes = BuyDevelopment.add(BuyOperations);\n    emit BuyFeesUpdated(BuyDevelopment, BuyOperations);\n}"
"function setSellTaxes(uint256 _newSellDevelopment, uint256 _newSellOperations) external onlyOwner {\n    SellDevelopment = _newSellDevelopment;\n    SellOperations = _newSellOperations;\n    sellTaxes = SellDevelopment.add(SellOperations);\n    emit SellFeesUpdated(SellDevelopment, SellOperations);\n}"
"function setSwapTokensAtAmount(uint256 _newAmount) external onlyOwner {\n    require(_newAmount > 0 && _newAmount <= (_totalSupply * 5) / 1000, ""Minimum swap amount must be greater than 0 and less than 0.5% of total supply!"");\n    swapTokensAtAmount = _newAmount;\n    emit SwapThresholdUpdated(swapTokensAtAmount);\n}"
function toggleSwapping() external onlyOwner {\n    swapAndLiquifyEnabled = (swapAndLiquifyEnabled) ? false : true;\n}
"function setWhitelistStatus(address _wallet, bool _status) external onlyOwner {\n    whitelisted[_wallet] = _status;\n    emit Whitelist(_wallet, _status);\n}"
"function setBlacklist(address _address, bool _isBlacklisted) external onlyOwner {\n    blacklisted[_address] = _isBlacklisted;\n    emit Blacklist(_address, _isBlacklisted);\n}"
function checkWhitelist(address _wallet) external view returns (bool) {\n    return whitelisted[_wallet];\n}
function checkBlacklist(address _address) external view returns (bool) {\n    return blacklisted[_address];\n}
"function _takeTax(\n    address _from,\n    address _to,\n    uint256 _amount\n) internal returns (uint256) {\n    if (whitelisted[_from] || whitelisted[_to]) {\n        return _amount;\n    }\n    uint256 totalTax = transferTaxes;\n\n    if (_to == pairAddress) {\n        totalTax = sellTaxes;\n    } else if (_from == pairAddress) {\n        totalTax = buyTaxes;\n    }\n\n    uint256 tax = 0;\n    if (totalTax > 0) {\n        tax = (_amount * totalTax) / 1000;\n        super._transfer(_from, address(this), tax);\n    }\n    return (_amount - tax);\n}"
"function internalSwap() internal {\n    isSwapping = true;\n    uint256 taxAmount = balanceOf(address(this)); \n    if (taxAmount == 0) {\n        return;\n    }\n\n    uint256 totalFee = (buyTaxes).add(sellTaxes);\n\n    uint256 DevelopmentShare =(BuyDevelopment).add(SellDevelopment);\n    uint256 OperationsShare = (BuyOperations).add(SellOperations);\n\n    if (DevelopmentShare == 0) {\n        totalFee = DevelopmentShare.add(OperationsShare);\n    }\n\n    uint256 halfLPTokens = 0;\n    if (totalFee > 0) {\n        halfLPTokens = taxAmount.mul(DevelopmentShare).div(totalFee).div(2);\n    }\n    uint256 swapTokens = taxAmount.sub(halfLPTokens);\n    uint256 initialBalance = address(this).balance;\n    swapToETH(swapTokens);\n    uint256 newBalance = address(this).balance.sub(initialBalance);\n\n    uint256 ethForDevelopment = 0;\n    if (DevelopmentShare > 0) {\n        ethForDevelopment = newBalance.mul(DevelopmentShare).div(totalFee).div(2);\n    \n    addLiquidity(halfLPTokens, ethForDevelopment);\n    emit SwapAndLiquify(halfLPTokens, ethForDevelopment, halfLPTokens);\n    }\n    uint256 ethForOperations = newBalance.mul(OperationsShare).div(totalFee);\n\n    transferToAddressETH(DevelopmentAddress, ethForDevelopment);\n    transferToAddressETH(OperationsAddress, ethForOperations);\n\n    isSwapping = false;\n}"
"function transferToAddressETH(address payable recipient, uint256 amount) private \n{\n    recipient.transfer(amount);\n}"
"function swapToETH(uint256 _amount) internal {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapRouter.WETH();\n    _approve(address(this), address(uniswapRouter), _amount);\n    uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        _amount,\n        0,\n        path,\n        address(this),\n        block.timestamp\n    );\n}"
"function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n    // approve token transfer to cover all possible scenarios\n    _approve(address(this), address(uniswapRouter), tokenAmount);\n\n    // add the liquidity\n    uniswapRouter.addLiquidityETH{value: ethAmount}(\n        address(this),\n        tokenAmount,\n        0, // slippage is unavoidable\n        0, // slippage is unavoidable\n        owner(),\n        block.timestamp\n    );\n}"
"function withdrawStuckETH() external onlyOwner {\n    uint256 balance = address(this).balance;\n    require(balance > 0, ""No ETH available to withdraw"");\n\n    (bool success, ) = address(msg.sender).call{value: balance}("""");\n    require(success, ""transferring ETH failed"");\n}"
"function withdrawStuckTokens(address ERC20_token) external onlyOwner {\n    require(ERC20_token != address(this), ""Owner cannot claim native tokens"");\n\n    uint256 tokenBalance = IERC20(ERC20_token).balanceOf(address(this));\n    require(tokenBalance > 0, ""No tokens available to withdraw"");\n\n    bool success = IERC20(ERC20_token).transfer(msg.sender, tokenBalance);\n    require(success, ""transferring tokens failed!"");\n}"
receive() external payable {}
"constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}"
"function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, ""SafeMath: addition overflow"");\n    return c;\n}"
"function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, ""SafeMath: subtraction overflow"");\n}"
"function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n    return c;\n}"
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n        return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, ""SafeMath: multiplication overflow"");\n    return c;\n}"
"function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, ""SafeMath: division by zero"");\n}"
"function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n}"
"function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, ""SafeMath: modulo by zero"");\n}"
"function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n}"
"constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n}"
function owner() public view returns (address) {\n    return _owner;\n}
"function mul(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a * b;\n\n    // Detect overflow when multiplying MIN_INT256 with -1\n    require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\n    require((b == 0) || (c / b == a));\n    return c;\n}"
"function div(int256 a, int256 b) internal pure returns (int256) {\n    // Prevent overflow when dividing MIN_INT256 by -1\n    require(b != -1 || a != MIN_INT256);\n\n    // Solidity already throws when dividing by 0.\n    return a / b;\n}"
"function sub(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a - b;\n    require((b >= 0 && c <= a) || (b < 0 && c > a));\n    return c;\n}"
"function add(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a + b;\n    require((b >= 0 && c >= a) || (b < 0 && c < a));\n    return c;\n}"
function abs(int256 a) internal pure returns (int256) {\n    require(a != MIN_INT256);\n    return a < 0 ? -a : a;\n}
function toUint256Safe(int256 a) internal pure returns (uint256) {\n    require(a >= 0);\n    return uint256(a);\n}
function toInt256Safe(uint256 a) internal pure returns (int256) {\n    int256 b = int256(a);\n    require(b >= 0);\n    return b;\n}
"constructor(string memory _name, string memory _symbol)\n    ERC20(_name, _symbol)\n{}"
receive() external payable {\n    distributeDividends();\n}
"function distributeDividends() public payable override {\n    require(totalSupply() > 0);\n\n    if (msg.value > 0) {\n        magnifiedDividendPerShare = magnifiedDividendPerShare.add(\n            (msg.value).mul(magnitude) / totalSupply()\n        );\n        emit DividendsDistributed(msg.sender, msg.value);\n\n        totalDividendsDistributed = totalDividendsDistributed.add(\n            msg.value\n        );\n    }\n}"
function dividendOf(address _owner) public view override returns (uint256) {\n    return withdrawableDividendOf(_owner);\n}
function withdrawableDividendOf(address _owner) public view override returns (uint256) {\n    return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\n}
function withdrawnDividendOf(address _owner) public view override returns (uint256) {\n    return withdrawnDividends[_owner];\n}
function accumulativeDividendOf(address _owner) public view override returns (uint256) {\n    return\n        magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()\n        .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\n}
"function _mint(address account, uint256 value) internal override {\n    super._mint(account, value);\n\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\n    .sub((magnifiedDividendPerShare.mul(value)).toInt256Safe());\n}"
"function _burn(address account, uint256 value) internal override {\n    super._burn(account, value);\n\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\n    .add((magnifiedDividendPerShare.mul(value)).toInt256Safe());\n}"
"function _setBalance(address account, uint256 newBalance) internal {\n    uint256 currentBalance = balanceOf(account);\n\n    if (newBalance > currentBalance) {\n        uint256 mintAmount = newBalance.sub(currentBalance);\n        _mint(account, mintAmount);\n    } \n    else if (newBalance < currentBalance) {\n        uint256 burnAmount = currentBalance.sub(newBalance);\n        _burn(account, burnAmount);\n    }\n}"
"constructor() ERC20(""Venom"", ""VNM"") {\n    marketingWallet = payable(0xB4ba72b728248Ba8caC7f1A8f560324340a6c239);\n    address router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    buyDeadFees = 2;\n    sellDeadFees = 2;\n    buyMarketingFees = 2;\n    sellMarketingFees = 2;\n    buyLiquidityFee = 0;\n    sellLiquidityFee = 0;\n    buyRewardsFee = 2;\n    sellRewardsFee = 2;\n    transferFee = 1;\n\n    totalBuyFees = buyRewardsFee.add(buyLiquidityFee).add(buyMarketingFees);\n    totalSellFees = sellRewardsFee.add(sellLiquidityFee).add(sellMarketingFees);\n\n    dividendTracker = new VenomDividendTracker(payable(this), router, address(this),\n                                               ""VenomTRACKER"", ""VNMTRACKER"");\n\n    uniswapV2Router = IUniswapV2Router02(router);\n    // Create a uniswap pair for this new token\n    uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\n            address(this),\n            uniswapV2Router.WETH()\n        );\n\n    _setAutomatedMarketMakerPair(uniswapV2Pair, true);\n\n    // exclude from receiving dividends\n    dividendTracker.excludeFromDividends(address(dividendTracker));\n    dividendTracker.excludeFromDividends(address(this));\n    dividendTracker.excludeFromDividends(DEAD);\n    dividendTracker.excludedFromDividends(address(0));\n    dividendTracker.excludeFromDividends(router);\n    dividendTracker.excludeFromDividends(marketingWallet);\n    dividendTracker.excludeFromDividends(owner());\n\n    // exclude from paying fees or having max transaction amount\n    _isExcludedFromFees[address(this)] = true;\n    _isExcludedFromFees[address(dividendTracker)] = true;\n    _isExcludedFromFees[address(marketingWallet)] = true;\n    _isExcludedFromFees[msg.sender] = true;\n\n    uint256 totalTokenSupply = (100_000_000_000) * (10**18);\n    _mint(owner(), totalTokenSupply); // only time internal mint function is ever called is to create supply\n    swapTokensAtAmount = totalTokenSupply / 2000; // 0.05%\n    minimumForDiamondHands = totalTokenSupply / 2000; // 0.05%\n    canTransferBeforeTradingIsEnabled[owner()] = true;\n    canTransferBeforeTradingIsEnabled[address(this)] = true;\n}"
receive() external payable {}
"function enableTrading(uint256 initialMaxGwei, uint256 initialMaxWallet, uint256 initialMaxTX,\n                       uint256 setDelay) external onlyOwner {\n    initialMaxWallet = initialMaxWallet * (10**18);\n    initialMaxTX = initialMaxTX * (10**18);\n    require(!tradingEnabled);\n    require(initialMaxWallet >= _totalSupply / 1000,""cannot set below 0.1%"");\n    require(initialMaxTX >= _totalSupply / 1000,""cannot set below 0.1%"");\n    maxWallet = initialMaxWallet;\n    maxTX = initialMaxTX;\n    gasPriceLimit = initialMaxGwei * 1 gwei;\n    tradingEnabled = true;\n    launchblock = block.number;\n    launchtimestamp = block.timestamp;\n    delay = setDelay;\n    emit TradingEnabled();\n}"
function setPresaleWallet(address wallet) external onlyOwner {\n    canTransferBeforeTradingIsEnabled[wallet] = true;\n    _isExcludedFromFees[wallet] = true;\n    dividendTracker.excludeFromDividends(wallet);\n    emit SetPreSaleWallet(wallet);\n}
"function setExcludeFees(address account, bool excluded) public onlyOwner {\n    _isExcludedFromFees[account] = excluded;\n    emit ExcludeFromFees(account, excluded);\n}"
function setExcludeDividends(address account) public onlyOwner {\n    dividendTracker.excludeFromDividends(account);\n}
"function setIncludeDividends(address account) public onlyOwner {\n    dividendTracker.includeFromDividends(account);\n    dividendTracker.setBalance(account, getMultiplier(account));\n}"
"function setCanTransferBefore(address wallet, bool enable) external onlyOwner {\n    canTransferBeforeTradingIsEnabled[wallet] = enable;\n}"
function setLimitsInEffect(bool value) external onlyOwner {\n    limitsInEffect = value;\n}
"function setGasPriceLimit(uint256 GWEI) external onlyOwner {\n    require(GWEI >= 50, ""can never be set lower than 50"");\n    gasPriceLimit = GWEI * 1 gwei;\n}"
"function setcooldowntimer(uint256 value) external onlyOwner {\n    require(value <= 300, ""cooldown timer cannot exceed 5 minutes"");\n    cooldowntimer = value;\n}"
"function setmaxWallet(uint256 value) external onlyOwner {\n    value = value * (10**18);\n    require(value >= _totalSupply / 1000, ""max wallet cannot be set to less than 0.1%"");\n    maxWallet = value;\n}"
function Sweep() external onlyOwner {\n    uint256 amountETH = address(this).balance;\n    payable(msg.sender).transfer(amountETH);\n}
"function setmaxTX(uint256 value) external onlyOwner {\n    value = value * (10**18);\n    require(value >= _totalSupply / 1000, ""max tx cannot be set to less than 0.1%"");\n    maxTX = value;\n}"
"function setMinimumForDiamondHands (uint256 value) external onlyOwner {\n    value = value * (10**18);\n    require(value <= _totalSupply / 2000, ""cannot be set to more than 0.05%"");\n    minimumForDiamondHands = value;\n}"
function setSwapTriggerAmount(uint256 amount) public onlyOwner {\n    swapTokensAtAmount = amount * (10**18);\n}
function enableSwapAndLiquify(bool enabled) public onlyOwner {\n    require(swapAndLiquifyEnabled != enabled);\n    swapAndLiquifyEnabled = enabled;\n    emit EnableSwapAndLiquify(enabled);\n}
"function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\n    _setAutomatedMarketMakerPair(pair, value);\n}"
function setAllowCustomTokens(bool allow) public onlyOwner {\n    dividendTracker.setAllowCustomTokens(allow);\n}
function setAllowAutoReinvest(bool allow) public onlyOwner {\n    dividendTracker.setAllowAutoReinvest(allow);\n}
"function _setAutomatedMarketMakerPair(address pair, bool value) private {\n    automatedMarketMakerPairs[pair] = value;\n\n    if (value) {\n        dividendTracker.excludeFromDividends(pair);\n    }\n\n    emit SetAutomatedMarketMakerPair(pair, value);\n}"
"function updateGasForProcessing(uint256 newValue) public onlyOwner {\n    require(newValue >= 200000 && newValue <= 5000000);\n    emit GasForProcessingUpdated(newValue, gasForProcessing);\n    gasForProcessing = newValue;\n}"
function transferAdmin(address newOwner) public onlyOwner {\n    dividendTracker.excludeFromDividends(newOwner);\n    _isExcludedFromFees[newOwner] = true;\n    transferOwnership(newOwner);\n}
"function updateTransferFee(uint256 newTransferFee) public onlyOwner {\n    require (newTransferFee <= 5, ""transfer fee cannot exceed 5%"");\n    transferFee = newTransferFee;\n    emit UpdateTransferFee(transferFee);\n}"
"function updateRewardsMultiplier() external {\n    if (!_multiplier[msg.sender]) {\n                _multiplier[msg.sender] = true;\n            }\n    dividendTracker.setBalance(msg.sender, getMultiplier(msg.sender));\n}"
"function updateFees(uint256 deadBuy, uint256 deadSell, uint256 marketingBuy, uint256 marketingSell,\n                    uint256 liquidityBuy, uint256 liquiditySell, uint256 RewardsBuy,\n                    uint256 RewardsSell) public onlyOwner {\n    \n    buyDeadFees = deadBuy;\n    buyMarketingFees = marketingBuy;\n    buyLiquidityFee = liquidityBuy;\n    buyRewardsFee = RewardsBuy;\n    sellDeadFees = deadSell;\n    sellMarketingFees = marketingSell;\n    sellLiquidityFee = liquiditySell;\n    sellRewardsFee = RewardsSell;\n\n    totalSellFees = sellRewardsFee.add(sellLiquidityFee).add(sellMarketingFees);\n\n    totalBuyFees = buyRewardsFee.add(buyLiquidityFee).add(buyMarketingFees);\n    require(deadBuy <= 3 && deadSell <= 3, ""burn fees cannot exceed 3%"");\n    require(totalSellFees <= 10 && totalBuyFees <= 10, ""total fees cannot exceed 10%"");\n\n    emit UpdateFees(sellDeadFees, sellMarketingFees, sellLiquidityFee, sellRewardsFee, buyDeadFees,\n                    buyMarketingFees, buyLiquidityFee, buyRewardsFee);\n}"
function getTotalDividendsDistributed() external view returns (uint256) {\n    return dividendTracker.totalDividendsDistributed();\n}
function isExcludedFromFees(address account) public view returns (bool) {\n    return _isExcludedFromFees[account];\n}
function withdrawableDividendOf(address account) public view returns (uint256) {\n    return dividendTracker.withdrawableDividendOf(account);\n}
function dividendTokenBalanceOf(address account) public view returns (uint256) {\n    return dividendTracker.balanceOf(account);\n}
"function getAccountDividendsInfo(address account) external view returns (address, int256, int256, uint256,\n                                                                         uint256, uint256) {\n    return dividendTracker.getAccount(account);\n}"
"function getAccountDividendsInfoAtIndex(uint256 index) external view returns (address, int256, int256,\n                                                                              uint256, uint256, uint256) {\n    return dividendTracker.getAccountAtIndex(index);\n}"
"function processDividendTracker(uint256 gas) external {\n    (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);\n    emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas);\n}"
"function claim() external {\n    dividendTracker.processAccount(payable(msg.sender), false);\n}"
function getLastProcessedIndex() external view returns (uint256) {\n    return dividendTracker.getLastProcessedIndex();\n}
function getNumberOfDividendTokenHolders() external view returns (uint256) {\n    return dividendTracker.getNumberOfTokenHolders();\n}
"function setAutoClaim(bool value) external {\n    dividendTracker.setAutoClaim(msg.sender, value);\n}"
"function setReinvest(bool value) external {\n    dividendTracker.setReinvest(msg.sender, value);\n}"
function setDividendsPaused(bool value) external onlyOwner {\n    dividendTracker.setDividendsPaused(value);\n}
function isExcludedFromAutoClaim(address account) external view returns (bool) {\n    return dividendTracker.isExcludedFromAutoClaim(account);\n}
function isReinvest(address account) external view returns (bool) {\n    return dividendTracker.isReinvest(account);\n}
"function _transfer(address from, address to, uint256 amount) internal override {\n    require(from != address(0), ""ERC20: transfer from the zero address"");\n    require(to != address(0), ""ERC20: transfer to the zero address"");\n    uint256 RewardsFee;\n    uint256 deadFees;\n    uint256 marketingFees;\n    uint256 liquidityFee;\n\n    if (!canTransferBeforeTradingIsEnabled[from]) {\n        require(tradingEnabled, ""Trading has not yet been enabled"");\n    }\n    if (amount == 0) {\n        super._transfer(from, to, 0);\n        return;\n    } \n\n    if (_isVesting[from]) {\n        if (block.timestamp < _vestingTimestamp[from] + 5 minutes) {\n            require(balanceOf(from) - amount >= tokensVesting[from], ""cant sell vested tokens"");\n        }\n        else {\n            tokensVesting[from] = 0;\n            _isVesting[from] = false;\n        }\n    }\n\n    \n    else if (!swapping && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\n        bool isSelling = automatedMarketMakerPairs[to];\n        bool isBuying = automatedMarketMakerPairs[from];\n\n        if (!isBuying && !isSelling) {\n            if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\n                uint256 tFees = amount.mul(transferFee).div(100);\n                amount = amount.sub(tFees);\n                super._transfer(from, address(this), tFees);\n                super._transfer(from, to, amount);\n                dividendTracker.setBalance(from, getMultiplier(from));\n                dividendTracker.setBalance(to, getMultiplier(to));\n                _diamondHands[from] = false;\n                _multiplier[from] = false;\n                _holderFirstBuyTimestamp[from] = block.timestamp;\n                return;\n            }\n            else {\n                super._transfer(from, to, amount);\n                dividendTracker.setBalance(from, getMultiplier(from));\n                dividendTracker.setBalance(to, getMultiplier(to));\n                _diamondHands[from] = false;\n                _multiplier[from] = false;\n                _holderFirstBuyTimestamp[from] = block.timestamp;\n                return;\n            }\n        }\n\n        else if (isSelling) {\n            if (amount >= minimumForDiamondHands) {\n                RewardsFee = 8;\n            }\n            else {\n                RewardsFee = sellRewardsFee;\n            }\n            deadFees = sellDeadFees;\n            marketingFees = sellMarketingFees;\n            liquidityFee = sellLiquidityFee;\n\n            if (limitsInEffect) {\n            require(block.timestamp >= _holderLastTransferTimestamp[from] + cooldowntimer,\n                    ""cooldown period active"");\n            require(amount <= maxTX,""above max transaction limit"");\n            _holderLastTransferTimestamp[from] = block.timestamp;\n\n            }\n            _diamondHands[from] = false;\n            _multiplier[from] = false;\n            _holderFirstBuyTimestamp[from] = block.timestamp;\n\n\n        } else if (isBuying) {\n\n            if (_diamondHands[to]) {\n                if (block.timestamp >= _holderBuy1Timestamp[to] + 1 days && balanceOf(to) >= minimumForDiamondHands) {\n                    super._transfer(from, to, amount);\n                    dividendTracker.setBalance(from, getMultiplier(from));\n                    dividendTracker.setBalance(to, getMultiplier(to));\n                    return;\n                }\n            }\n\n            if (!_multiplier[to]) {\n                _multiplier[to] = true;\n                _holderFirstBuyTimestamp[to] = block.timestamp;\n            }\n\n            if (!_diamondHands[to]) {\n                _diamondHands[to] = true;\n                _holderBuy1Timestamp[to] = block.timestamp;\n            }\n\n            RewardsFee = buyRewardsFee;\n            deadFees = buyDeadFees;\n            marketingFees = buyMarketingFees;\n            liquidityFee = buyLiquidityFee;\n\n            if (limitsInEffect) {\n            require(block.timestamp > launchtimestamp + delay,""you shall not pass"");\n            require(tx.gasprice <= gasPriceLimit,""Gas price exceeds limit."");\n            require(_holderLastTransferBlock[to] != block.number,""Too many TX in block"");\n            require(amount <= maxTX,""above max transaction limit"");\n            _holderLastTransferBlock[to] = block.number;\n            }\n\n            uint256 contractBalanceRecipient = balanceOf(to);\n            require(contractBalanceRecipient + amount <= maxWallet,""Exceeds maximum wallet token amount."" );\n        }\n\n        uint256 totalFees = RewardsFee.add(liquidityFee + marketingFees);\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n        if (canSwap && isSelling) {\n            swapping = true;\n\n            if (swapAndLiquifyEnabled && liquidityFee > 0 && totalBuyFees > 0) {\n                uint256 totalBuySell = buyAmount.add(sellAmount);\n                uint256 swapAmountBought = contractTokenBalance.mul(buyAmount).div(totalBuySell);\n                uint256 swapAmountSold = contractTokenBalance.mul(sellAmount).div(totalBuySell);\n                uint256 swapBuyTokens = swapAmountBought.mul(liquidityFee).div(totalBuyFees);\n                uint256 swapSellTokens = swapAmountSold.mul(liquidityFee).div(totalSellFees);\n                uint256 swapTokens = swapSellTokens.add(swapBuyTokens);\n\n                swapAndLiquify(swapTokens);\n            }\n\n            uint256 remainingBalance = balanceOf(address(this));\n            swapAndSendDividends(remainingBalance);\n            buyAmount = 1;\n            sellAmount = 1;\n            swapping = false;\n        }\n\n        uint256 fees = amount.mul(totalFees).div(100);\n        uint256 burntokens;\n\n        if (deadFees > 0) {\n        burntokens = amount.mul(deadFees) / 100;\n        super._transfer(from, DEAD, burntokens);\n        _totalSupply = _totalSupply.sub(burntokens);\n\n        }\n\n        amount = amount.sub(fees + burntokens);\n\n        if (isSelling) {\n            sellAmount = sellAmount.add(fees);\n        } \n        else {\n            buyAmount = buyAmount.add(fees);\n        }\n\n        super._transfer(from, address(this), fees);\n\n        uint256 gas = gasForProcessing;\n\n        try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\n            emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas);\n        } catch {}\n    }\n\n    super._transfer(from, to, amount);\n    dividendTracker.setBalance(from, getMultiplier(from));\n    dividendTracker.setBalance(to, getMultiplier(to));\n}"
function getMultiplier(address account) private view returns (uint256) {\n    uint256 multiplier;\n    if (_multiplier[account] && block.timestamp > _holderFirstBuyTimestamp[account] + 1 weeks && \n        block.timestamp < _holderFirstBuyTimestamp[account] + 2 weeks) {\n        multiplier = balanceOf(account).mul(3);\n    }\n    else if (_multiplier[account] && block.timestamp > _holderFirstBuyTimestamp[account] + 2 weeks && \n             block.timestamp < _holderFirstBuyTimestamp[account] + 3 weeks) {\n                 multiplier = balanceOf(account).mul(5);\n    }\n    else if (_multiplier[account] && block.timestamp > _holderFirstBuyTimestamp[account] + 3 weeks) {\n                 multiplier = balanceOf(account).mul(7);\n    }\n    else {\n        multiplier = balanceOf(account);\n    }\n    \n    return\n            multiplier;\n}
"function swapAndLiquify(uint256 tokens) private {\n    uint256 half = tokens.div(2);\n    uint256 otherHalf = tokens.sub(half);\n    uint256 initialBalance = address(this).balance;\n    swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n    uint256 newBalance = address(this).balance.sub(initialBalance);\n    addLiquidity(otherHalf, newBalance);\n    emit SwapAndLiquify(half, newBalance, otherHalf);\n}"
"function swapTokensForEth(uint256 tokenAmount) private {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, // accept any amount of ETH\n        path,\n        address(this),\n        block.timestamp\n    );\n}"
function updatePayoutToken(address token) public onlyOwner {\n    dividendTracker.updatePayoutToken(token);\n    emit UpdatePayoutToken(token);\n}
function getPayoutToken() public view returns (address) {\n    return dividendTracker.getPayoutToken();\n}
function setMinimumTokenBalanceForAutoDividends(uint256 value) public onlyOwner {\n    dividendTracker.setMinimumTokenBalanceForAutoDividends(value);\n}
function setMinimumTokenBalanceForDividends(uint256 value) public onlyOwner {\n    dividendTracker.setMinimumTokenBalanceForDividends(value);\n}
"function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n    // approve token transfer to cover all possible scenarios\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    // add the liquidity\n    uniswapV2Router.addLiquidityETH{value: ethAmount}(\n        address(this),\n        tokenAmount,\n        0, // slippage is unavoidable\n        0, // slippage is unavoidable\n        address(0),\n        block.timestamp\n    );\n}"
function forceSwapAndSendDividends(uint256 tokens) public onlyOwner {\n    tokens = tokens * (10**18);\n    uint256 totalAmount = buyAmount.add(sellAmount);\n    uint256 fromBuy = tokens.mul(buyAmount).div(totalAmount);\n    uint256 fromSell = tokens.mul(sellAmount).div(totalAmount);\n\n    swapAndSendDividends(tokens);\n\n    buyAmount = buyAmount.sub(fromBuy);\n    sellAmount = sellAmount.sub(fromSell);\n}
"function swapAndSendDividends(uint256 tokens) private {\n    if (tokens == 0) {\n        return;\n    }\n    swapTokensForEth(tokens);\n    uint256 totalAmount = buyAmount.add(sellAmount);\n\n    bool success = true;\n    bool successOp1 = true;\n\n    uint256 dividends;\n    uint256 dividendsFromBuy;\n    uint256 dividendsFromSell;\n\n    if (buyRewardsFee > 0) {\n        dividendsFromBuy = address(this).balance.mul(buyAmount).div(totalAmount)\n        .mul(buyRewardsFee).div(buyRewardsFee + buyMarketingFees);\n    }\n    if (sellRewardsFee > 0) {\n        dividendsFromSell = address(this).balance.mul(sellAmount).div(totalAmount)\n        .mul(sellRewardsFee).div(sellRewardsFee + sellMarketingFees);\n    }\n    dividends = dividendsFromBuy.add(dividendsFromSell);\n\n    if (dividends > 0) {\n        (success, ) = address(dividendTracker).call{value: dividends}("""");\n    }\n    \n    uint256 _completeFees = sellMarketingFees + buyMarketingFees;\n\n    uint256 feePortions;\n    if (_completeFees > 0) {\n        feePortions = address(this).balance.div(_completeFees);\n    }\n    uint256 marketingPayout = buyMarketingFees.add(sellMarketingFees).mul(feePortions);\n\n    if (marketingPayout > 0) {\n        (successOp1, ) = address(marketingWallet).call{value: marketingPayout}("""");\n    }\n\n    emit SendDividends(dividends, marketingPayout, success && successOp1);\n}"
"function airdropToWallets(\n    address[] memory airdropWallets,\n    uint256[] memory amount\n) external onlyOwner {\n    require(airdropWallets.length == amount.length,""Arrays must be the same length"");\n    require(airdropWallets.length <= 200, ""Wallets list length must be <= 200"");\n    for (uint256 i = 0; i < airdropWallets.length; i++) {\n        address wallet = airdropWallets[i];\n        uint256 airdropAmount = amount[i] * (10**18);\n        super._transfer(msg.sender, wallet, airdropAmount);\n        dividendTracker.setBalance(payable(wallet), getMultiplier(wallet));\n    }\n}"
"function airdropToWalletsAndVest(\n    address[] memory airdropWallets,\n    uint256[] memory amount\n) external onlyOwner {\n    require(airdropWallets.length == amount.length, ""Arrays must be the same length"");\n    require(airdropWallets.length <= 200, ""Wallets list length must be <= 200"");\n    for (uint256 i = 0; i < airdropWallets.length; i++) {\n        address wallet = airdropWallets[i];\n        uint256 airdropAmount = amount[i] * (10**18);\n        super._transfer(msg.sender, wallet, airdropAmount);\n        dividendTracker.setBalance(payable(wallet), getMultiplier(wallet));\n        tokensVesting[wallet] = airdropAmount;\n        _isVesting[wallet] = true;\n        _vestingTimestamp[wallet] = block.timestamp;\n    }\n}"
"constructor(address payable mainContract, address router, address token, string memory _name,\n            string memory _ticker) DividendPayingToken(_name, _ticker) {\n    \n    trackerName = _name;\n    trackerTicker = _ticker;\n    defaultToken = token;\n    VenomContract = Venom(mainContract);\n    minimumTokenBalanceForAutoDividends = 1_000000000000000000; // 1 token\n    minimumTokenBalanceForDividends = minimumTokenBalanceForAutoDividends;\n\n    uniswapV2Router = IUniswapV2Router02(router);\n    allowCustomTokens = true;\n    allowAutoReinvest = false;\n}"
"function _transfer(address, address, uint256) internal pure override {\n    require(false, ""No transfers allowed"");\n}"
"function withdrawDividend() public pure override {\n    require(false, ""withdrawDividend disabled. Use the 'claim' function on the main Venom contract."");\n}"
function isExcludedFromAutoClaim(address account) external view onlyOwner returns (bool) {\n    return excludedFromAutoClaim[account];\n}
function isReinvest(address account) external view onlyOwner returns (bool) {\n    return autoReinvest[account];\n}
function setAllowCustomTokens(bool allow) external onlyOwner {\n    require(allowCustomTokens != allow);\n    allowCustomTokens = allow;\n    emit SetAllowCustomTokens(allow);\n}
function setAllowAutoReinvest(bool allow) external onlyOwner {\n    require(allowAutoReinvest != allow);\n    allowAutoReinvest = allow;\n    emit SetAllowAutoReinvest(allow);\n}
"function excludeFromDividends(address account) external onlyOwner {\n    //require(!excludedFromDividends[account]);\n    excludedFromDividends[account] = true;\n\n    _setBalance(account, 0);\n    tokenHoldersMap.remove(account);\n\n    emit ExcludeFromDividends(account);\n}"
function includeFromDividends(address account) external onlyOwner {\n    excludedFromDividends[account] = false;\n}
"function setAutoClaim(address account, bool value) external onlyOwner {\n    excludedFromAutoClaim[account] = value;\n}"
"function setReinvest(address account, bool value) external onlyOwner {\n    autoReinvest[account] = value;\n}"
function setMinimumTokenBalanceForAutoDividends(uint256 value) external onlyOwner {\n    minimumTokenBalanceForAutoDividends = value * (10**18);\n}
function setMinimumTokenBalanceForDividends(uint256 value) external onlyOwner {\n    minimumTokenBalanceForDividends = value * (10**18);\n}
function setDividendsPaused(bool value) external onlyOwner {\n    require(dividendsPaused != value);\n    dividendsPaused = value;\n    emit DividendsPaused(value);\n}
function getLastProcessedIndex() external view returns (uint256) {\n    return lastProcessedIndex;\n}
function getNumberOfTokenHolders() external view returns (uint256) {\n    return tokenHoldersMap.keys.length;\n}
"function getAccount(address _account) public view returns (address account, int256 index, int256 iterationsUntilProcessed,\n                                                           uint256 withdrawableDividends, uint256 totalDividends,\n                                                           uint256 lastClaimTime) {\n    account = _account;\n    index = tokenHoldersMap.getIndexOfKey(account);\n    iterationsUntilProcessed = -1;\n\n    if (index >= 0) {\n        if (uint256(index) > lastProcessedIndex) {\n            iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\n        } \n        else {\n            uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length >\n                lastProcessedIndex\n                ? tokenHoldersMap.keys.length.sub(lastProcessedIndex)\n                : 0;\n\n            iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\n        }\n    }\n\n    withdrawableDividends = withdrawableDividendOf(account);\n    totalDividends = accumulativeDividendOf(account);\n\n    lastClaimTime = lastClaimTimes[account];\n}"
"function getAccountAtIndex(uint256 index) public view returns (address, int256, int256, uint256,\n                                                               uint256, uint256) {\n    if (index >= tokenHoldersMap.size()) {\n        return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0);\n    }\n\n    address account = tokenHoldersMap.getKeyAtIndex(index);\n\n    return getAccount(account);\n}"
"function setBalance(address account, uint256 newBalance) external onlyOwner\n{\n    if (excludedFromDividends[account]) {\n        return;\n    }\n\n    if (newBalance < minimumTokenBalanceForDividends) {\n        tokenHoldersMap.remove(account);\n        _setBalance(account, 0);\n\n        return;\n    }\n\n    _setBalance(account, newBalance);\n\n    if (newBalance >= minimumTokenBalanceForAutoDividends) {\n        tokenHoldersMap.set(account, newBalance);\n    } \n    else {\n        tokenHoldersMap.remove(account);\n    }\n}"
"function process(uint256 gas) public returns (uint256, uint256, uint256)\n{\n    uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\n\n    if (numberOfTokenHolders == 0 || dividendsPaused) {\n        return (0, 0, lastProcessedIndex);\n    }\n\n    uint256 _lastProcessedIndex = lastProcessedIndex;\n\n    uint256 gasUsed = 0;\n\n    uint256 gasLeft = gasleft();\n\n    uint256 iterations = 0;\n    uint256 claims = 0;\n\n    while (gasUsed < gas && iterations < numberOfTokenHolders) {\n        _lastProcessedIndex++;\n\n        if (_lastProcessedIndex >= numberOfTokenHolders) {\n            _lastProcessedIndex = 0;\n        }\n\n        address account = tokenHoldersMap.keys[_lastProcessedIndex];\n\n        if (!excludedFromAutoClaim[account]) {\n            if (processAccount(payable(account), true)) {\n                claims++;\n            }\n        }\n\n        iterations++;\n\n        uint256 newGasLeft = gasleft();\n\n        if (gasLeft > newGasLeft) {\n            gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\n        }\n\n        gasLeft = newGasLeft;\n    }\n\n    lastProcessedIndex = _lastProcessedIndex;\n\n    return (iterations, claims, lastProcessedIndex);\n}"
"function processAccount(address payable account, bool automatic) public onlyOwner\n    returns (bool)\n{\n    if (dividendsPaused) {\n        return false;\n    }\n\n    bool reinvest = autoReinvest[account];\n\n    if (automatic && reinvest && !allowAutoReinvest) {\n        return false;\n    }\n\n    uint256 amount = reinvest\n        ? _reinvestDividendOfUser(account)\n        : _withdrawDividendOfUser(account);\n\n    if (amount > 0) {\n        lastClaimTimes[account] = block.timestamp;\n        if (reinvest) {\n            emit DividendReinvested(account, amount, automatic);\n        } \n        else {\n            emit Claim(account, amount, automatic);\n        }\n        return true;\n    }\n\n    return false;\n}"
function updateUniswapV2Router(address newAddress) public onlyOwner {\n    uniswapV2Router = IUniswapV2Router02(newAddress);\n}
function updatePayoutToken(address token) public onlyOwner {\n    defaultToken = token;\n}
function getPayoutToken() public view returns (address) {\n    return defaultToken;\n}
"function _reinvestDividendOfUser(address account) private returns (uint256) {\n    uint256 _withdrawableDividend = withdrawableDividendOf(account);\n    if (_withdrawableDividend > 0) {\n        bool success;\n\n        withdrawnDividends[account] = withdrawnDividends[account].add(_withdrawableDividend);\n\n        address[] memory path = new address[](2);\n        path[0] = uniswapV2Router.WETH();\n        path[1] = address(VenomContract);\n\n        uint256 prevBalance = VenomContract.balanceOf(address(this));\n\n        // make the swap\n        try\n            uniswapV2Router\n                .swapExactETHForTokensSupportingFeeOnTransferTokens{value: _withdrawableDividend}\n                (0, path, address(this), block.timestamp)\n        {\n            uint256 received = VenomContract.balanceOf(address(this)).sub(prevBalance);\n            if (received > 0) {\n                success = true;\n                VenomContract.transfer(account, received);\n            } \n            else {\n                success = false;\n            }\n        } catch {\n            success = false;\n        }\n\n        if (!success) {\n            withdrawnDividends[account] = withdrawnDividends[account].sub(_withdrawableDividend);\n            return 0;\n        }\n\n        return _withdrawableDividend;\n    }\n\n    return 0;\n}"
"function _withdrawDividendOfUser(address payable user) internal override returns (uint256)\n{\n    uint256 _withdrawableDividend = withdrawableDividendOf(user);\n    if (_withdrawableDividend > 0) {\n        withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\n\n        address tokenAddress = defaultToken;\n        bool success;\n\n        if (tokenAddress == address(0)) {\n            (success, ) = user.call{value: _withdrawableDividend, gas: 3000}("""");\n        } \n        else {\n            address[] memory path = new address[](2);\n            path[0] = uniswapV2Router.WETH();\n            path[1] = tokenAddress;\n            try\n                uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{\n                value: _withdrawableDividend}(0, path, user, block.timestamp)\n            {\n                success = true;\n            } catch {\n                success = false;\n            }\n        }\n\n        if (!success) {\n            withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\n            return 0;\n        } \n        else {\n            emit DividendWithdrawn(user, _withdrawableDividend);\n        }\n        return _withdrawableDividend;\n    }\n    return 0;\n}"
"function get(Map storage map, address key) internal view returns (uint256) {\n    return map.values[key];\n}"
"function getIndexOfKey(Map storage map, address key) internal view returns (int256) {\n    if (!map.inserted[key]) {\n        return -1;\n    }\n    return int256(map.indexOf[key]);\n}"
"function getKeyAtIndex(Map storage map, uint256 index) internal view returns (address) {\n    return map.keys[index];\n}"
function size(Map storage map) internal view returns (uint256) {\n    return map.keys.length;\n}
"function set(Map storage map, address key, uint256 val) internal {\n    if (map.inserted[key]) {\n        map.values[key] = val;\n    } else {\n        map.inserted[key] = true;\n        map.values[key] = val;\n        map.indexOf[key] = map.keys.length;\n        map.keys.push(key);\n    }\n}"
"function remove(Map storage map, address key) internal {\n    if (!map.inserted[key]) {\n        return;\n    }\n\n    delete map.inserted[key];\n    delete map.values[key];\n\n    uint256 index = map.indexOf[key];\n    uint256 lastIndex = map.keys.length - 1;\n    address lastKey = map.keys[lastIndex];\n\n    map.indexOf[lastKey] = index;\n    delete map.indexOf[key];\n\n    map.keys[index] = lastKey;\n    map.keys.pop();\n}"
"function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n        return ""0"";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n        digits++;\n        temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n        digits -= 1;\n        buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n        value /= 10;\n    }\n    return string(buffer);\n}"
"function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n        return ""0x00"";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n        length++;\n        temp >>= 8;\n    }\n    return toHexString(value, length);\n}"
"function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = ""0"";\n    buffer[1] = ""x"";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n        buffer[i] = _HEX_SYMBOLS[value & 0xf];\n        value >>= 4;\n    }\n    require(value == 0, ""Strings: hex length insufficient"");\n    return string(buffer);\n}"
"function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n\n    uint256 size;\n    assembly {\n        size := extcodesize(account)\n    }\n    return size > 0;\n}"
"function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n    (bool success, ) = recipient.call{value: amount}("""");\n    require(success, ""Address: unable to send value, recipient may have reverted"");\n}"
"function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, ""Address: low-level call failed"");\n}"
"function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(address(this).balance >= value, ""Address: insufficient balance for call"");\n    require(isContract(target), ""Address: call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, ""Address: low-level static call failed"");\n}"
"function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal view returns (bytes memory) {\n    require(isContract(target), ""Address: static call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n}"
"function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(isContract(target), ""Address: delegate call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n) internal pure returns (bytes memory) {\n    if (success) {\n        return returndata;\n    } else {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}"
constructor() {\n    _paused = false;\n}
"constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}"
"function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n) private returns (bool) {\n    if (to.isContract()) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver.onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert(""ERC721: transfer to non ERC721Receiver implementer"");\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    } else {\n        return true;\n    }\n}"
constructor() {\n    _status = _NOT_ENTERED;\n}
"function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n}"
"function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n}"
"function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n}"
"function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n}"
"function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n}"
"function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n}"
"function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n}"
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n}"
"function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n}"
"function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a % b;\n}"
"function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n}"
"function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n}"
"function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}"
constructor() {\n    _setOwner(_msgSender());\n}
"function _setOwner(address newOwner) private {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n}"
"function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n    uint256 length = ERC721.balanceOf(to);\n    _ownedTokens[to][length] = tokenId;\n    _ownedTokensIndex[tokenId] = length;\n}"
function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n    _allTokensIndex[tokenId] = _allTokens.length;\n    _allTokens.push(tokenId);\n}
"function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n    // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n    // then delete the last slot (swap and pop).\n\n    uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n    // When the token to delete is the last token, the swap operation is unnecessary\n    if (tokenIndex != lastTokenIndex) {\n        uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n        _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n    }\n\n    // This also deletes the contents at the last position of the array\n    delete _ownedTokensIndex[tokenId];\n    delete _ownedTokens[from][lastTokenIndex];\n}"
"function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n    // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n    // then delete the last slot (swap and pop).\n\n    uint256 lastTokenIndex = _allTokens.length - 1;\n    uint256 tokenIndex = _allTokensIndex[tokenId];\n\n    // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n    // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n    // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n    uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n    _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n    _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n    // This also deletes the contents at the last position of the array\n    delete _allTokensIndex[tokenId];\n    _allTokens.pop();\n}"
"constructor(\n    string memory name,\n    string memory symbol,\n    string memory baseTokenURI,\n    address mbeneficiary,\n    address rbeneficiary,\n    address alarmContract,\n    address rngContract\n) ERC721(name, symbol) Ownable() {\n    locked = false;\n\n    _mintPrice = 1 ether;\n    _reservesRate = 200;\n    _maxTokenId = 1000000;\n\n    _baseExtension = "".json"";\n    _baseTokenURI = baseTokenURI;\n\n    _mintingBeneficiary = payable(mbeneficiary);\n    _rngContract = rngContract;\n    _alarmContract = alarmContract;\n    _minter = _msgSender();\n\n    _state = DrawState.Closed;\n\n    royalties[0] = RoyaltyReceiver(rbeneficiary, 100);\n}"
"function feed(uint256 intoReserves, uint256 intoGrandPrize)\n    external\n    payable\n    onlyOwner\n{\n    require(\n        msg.value > 0 && intoReserves.add(intoGrandPrize) == msg.value,\n        ""DCBW721: Balance-Value Mismatch""\n    );\n    _updateGrandPrizePool(_grandPrizePool.add(intoGrandPrize));\n    _updateReserves(_reserves.add(intoReserves));\n}"
"receive() external payable {\n    revert(""DCBW721: Please use Mint or Admin calls"");\n}"
"fallback() external payable {\n    revert(""DCBW721: Please use Mint or Admin calls"");\n}"
"function updateAddressesAndTransferOwnership(\n    address mintingBeneficiary,\n    address alarmContract,\n    address rngContract,\n    address minter,\n    address _owner\n) external onlyOwner {\n    changeMintBeneficiary(mintingBeneficiary);\n    changeMinter(minter);\n\n    setAlarmAccount(alarmContract);\n    setVRFAccount(rngContract);\n\n    transferOwnership(_owner);\n}"
"function royaltyInfo(uint tokenId, uint salePrice)\n    external\n    view\n    returns (address, uint) {\n    /// @notice all tokens have same royalty receiver\n    tokenId = 0; // silence unused var warning\n    return (royalties[tokenId].account, royalties[tokenId].shares.mul(salePrice).div(1000));\n}"
"function adminMint(address to, uint256 _tokenId)\n    external\n    whenNotPaused\n    ownerOrMinter\n    requireState(DrawState.Closed)\n{\n    require(to != address(0), ""DCBW721: Address cannot be 0"");\n\n    validateTokenId(_tokenId);\n\n    _safeMint(to, _tokenId);\n\n    emit AdminMinted(to, _tokenId);\n}"
"function mint(address to, uint256 _tokenId)\n    external\n    payable\n    whenNotPaused\n    requireState(DrawState.Closed)\n{\n    uint256 received = msg.value;\n\n    require(to != address(0), ""DCBW721: Address cannot be 0"");\n    require(\n        received == _mintPrice,\n        ""DCBW721: Ether sent mismatch with mint price""\n    );\n\n    validateTokenId(_tokenId);\n\n    _safeMint(to, _tokenId);\n\n    _forwardFunds(received);\n    _updateReserves(_reserves.add(received.mul(_reservesRate).div(1000)));\n\n    emit Minted(to, _tokenId);\n}"
"function drawNumber()\n    external\n    whenNotPaused\n    requireAccount(_alarmContract)\n    requireState(DrawState.Closed)\n    nonReentrant\n    returns (bool)\n{\n    require(_reserves > 0, ""DCBW721: Not enough reserves for draw"");\n    require(totalSupply() >= 500, ""DCBW721: Supply of 500 not reached yet"");\n\n    require(\n        _reserves != 0 && address(this).balance.sub(_grandPrizePool) >= _reserves,\n        ""DCBW721: Not enough balance for draw prize""\n    );\n\n    bytes32 reqId = IRNG(_rngContract).request();\n\n    _state = DrawState.Open;\n    draws[_drawsToDate] = DrawData(\n        _drawsToDate,\n        uint32(block.timestamp), /* solium-disable-line */\n        0,\n        0,\n        address(0),\n        0,\n        _state,\n        reqId\n    );\n\n    emit DrawInitiated(reqId);\n\n    return true;\n}"
"function drawNumberGrandPrize()\n    external\n    payable\n    whenNotPaused\n    onlyOwner\n    requireState(DrawState.Closed)\n    nonReentrant\n    returns (bool)\n{\n    if(msg.value > 0){\n        _updateGrandPrizePool(_grandPrizePool.add(msg.value));\n    }\n\n    require(\n        _grandPrizePool != 0 && address(this).balance.sub(_reserves) >= _grandPrizePool,\n        ""DCBW721: Not enough balance for grand prize""\n    );\n\n    bytes32 reqId = IRNG(_rngContract).request();\n\n    _state = DrawState.Open;\n    draws[_drawsToDate] = DrawData(\n        _drawsToDate,\n        uint32(block.timestamp), /* solium-disable-line */\n        0,\n        1,\n        address(0),\n        0,\n        _state,\n        reqId\n    );\n\n    emit DrawInitiated(reqId);\n\n    return true;\n}"
"function numberDrawn(bytes32 _requestId, uint256 _randomness)\n    external\n    whenNotPaused\n    requireAccount(_rngContract)\n    nonReentrant\n{\n    DrawData storage current = draws[_drawsToDate];\n    require(\n        current.randomNumberRequestId == _requestId,\n        ""DCBW721: Request ID mismatch""\n    );\n\n    current.winningEdition = uint64(uint256(_randomness % _maxTokenId).add(1));\n\n    if (_exists(current.winningEdition)) {\n        current.winner = ownerOf(current.winningEdition);\n        current.prizePoolWon = current.isGrandPrize == uint96(1)\n            ? uint96(_grandPrizePool)\n            : uint96(_reserves);\n        _payout(current);\n    }\n\n    emit DrawFinished(current.winner, current.winningEdition);\n\n    /// @notice update state\n    _drawsToDate++;\n    _state = DrawState.Closed;\n\n    /// @notice update draw record\n    current.state = _state;\n}"
"function _payout(DrawData memory current) private {\n    require(current.winner != address(0), ""DCBW721: Address cannot be 0"");\n    require(current.prizePoolWon > 0, ""DCBW721: Prize pool is empty"");\n\n    /// @notice updating reserve pool & grand prize pool\n    if (current.isGrandPrize == 1) {\n        _updateGrandPrizePool(0);\n    } else {\n        _updateReserves(0);\n    }\n\n    /// @notice forward prize to winner wallet using CALL to avoid 2300 stipend limit\n    (bool success, ) = payable(current.winner).call{value: current.prizePoolWon}("""");\n    require(success, ""DCBW721: Failed to forward prize"");\n}"
function resetDrawState() public onlyOwner {\n    _state = DrawState.Closed;\n}
"function changeMinter(address minter) public onlyOwner {\n    require(\n        minter != address(0),\n        ""DCBW721: Minter cannot be address 0""\n    );\n    require(\n        minter != _minter,\n        ""DCBW721: Minter cannot be same as previous""\n    );\n    _minter = minter;\n}"
"function changeMintBeneficiary(address beneficiary) public onlyOwner {\n    require(\n        beneficiary != address(0),\n        ""DCBW721: Minting beneficiary cannot be address 0""\n    );\n    require(\n        beneficiary != _mintingBeneficiary,\n        ""DCBW721: beneficiary cannot be same as previous""\n    );\n    _mintingBeneficiary = payable(beneficiary);\n}"
"function changeRoyaltiesBeneficiary(address beneficiary, uint32 shares) public onlyOwner {\n    require(\n        beneficiary != address(0),\n        ""DCBW721: Royalties beneficiary cannot be address 0""\n    );\n    require(shares > 0, 'DCBW721: Royalty shares cannot be 0');\n\n    RoyaltyReceiver storage rr = royalties[0];\n    rr.account = beneficiary;\n    rr.shares = shares;\n}"
"function changeMintCost(uint256 mintCost) public onlyOwner {\n    require(\n        mintCost != _mintPrice,\n        ""DCBW721: mint Cost cannot be same as previous""\n    );\n    _mintPrice = mintCost;\n}"
"function changeBaseURI(string memory newBaseURI)\n    public\n    onlyOwner\n    notLocked\n{\n    require((keccak256(abi.encodePacked((_baseTokenURI))) != keccak256(abi.encodePacked((newBaseURI)))), ""DCBW721: Base URI cannot be same as previous"");\n    _baseTokenURI = newBaseURI;\n}"
"function changeReserveRate(uint256 reservesRate) public onlyOwner {\n    require(\n        _reservesRate != reservesRate,\n        ""DCBW721: reservesRate cannot be same as previous""\n    );\n    _reservesRate = reservesRate;\n}"
function lockMetadata() public onlyOwner notLocked {\n    locked = true;\n}
function isTokenMinted(uint256 _tokenId) public view returns (bool) {\n    return validateTokenId(_tokenId) && _exists(_tokenId);\n}
"function validateTokenId(uint256 _tokenId) public view returns (bool) {\n    require(_tokenId >= 1, ""DCBW721: Invalid token ID"");\n    require(_tokenId <= _maxTokenId, ""DCBW721: Invalid token ID"");\n    return true;\n}"
"function _updateReserves(uint256 reserves) internal {\n    require(\n        reserves <= address(this).balance.sub(_grandPrizePool),\n        ""DCBW721: Reserve-Balance Mismatch""\n    );\n    _reserves = reserves;\n}"
"function _updateGrandPrizePool(uint256 grandPrize) internal {\n    require(\n        grandPrize <= address(this).balance.sub(_reserves),\n        ""DCBW721: GrandPrize-Balance Mismatch""\n    );\n    _grandPrizePool = grandPrize;\n}"
"function _forwardFunds(uint256 received) internal {\n    /// @notice forward fund to receiver wallet using CALL to avoid 2300 stipend limit\n    (bool success, ) = _mintingBeneficiary.call{value: received.mul(uint256(1000).sub(_reservesRate)).div(1000)}("""");\n    require(success, ""DCBW721: Failed to forward funds"");\n}"
constructor() {\n    _status = _NOT_ENTERED;\n}
"constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n}"
function owner() public view returns (address) {\n    return _owner;\n}
"constructor() {\n    _balances[address(this)] = _totalSupply;\n\n    isFeeExempt[msg.sender] = true;\n    isFeeExempt[MIGRATION_WALLET] = true;\n    \n    isTxLimitExempt[MIGRATION_WALLET] = true;\n    isTxLimitExempt[msg.sender] = true;\n    isTxLimitExempt[address(this)] = true;\n    isTxLimitExempt[DEAD] = true;\n    isTxLimitExempt[address(0)] = true;\n\n    emit Transfer(address(0), address(this), _totalSupply);\n}"
function totalSupply() external pure override returns (uint256) {\n    return _totalSupply;\n}
function balanceOf(address account) public view override returns (uint256) {\n    return _balances[account];\n}
"function allowance(address holder, address spender)\n    external\n    view\n    override\n    returns (uint256)\n{\n    return _allowances[holder][spender];\n}"
function name() public pure returns (string memory) {\n    return _name;\n}
function symbol() public pure returns (string memory) {\n    return _symbol;\n}
function decimals() public pure returns (uint8) {\n    return _decimals;\n}
"function approve(address spender, uint256 amount)\n    public\n    override\n    returns (bool)\n{\n    require(spender != address(0), ""SRG20: approve to the zero address"");\n    require(\n        msg.sender != address(0),\n        ""SRG20: approve from the zero address""\n    );\n\n    _allowances[msg.sender][spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n}"
"function approveMax(address spender) external returns (bool) {\n    return approve(spender, type(uint256).max);\n}"
function getCirculatingSupply() public view returns (uint256) {\n    return _totalSupply - _balances[DEAD];\n}
"function changeWalletLimit(uint256 newLimit) external onlyOwner {\n    require(\n        newLimit >= _totalSupply / 100,\n        ""New wallet limit should be at least 1% of total supply""\n    );\n    maxBag = newLimit;\n    emit MaxBagChanged(newLimit);\n}"
"function changeIsFeeExempt(address holder, bool exempt) external onlyOwner {\n    isFeeExempt[holder] = exempt;\n}"
"function changeIsTxLimitExempt(address holder, bool exempt)\n    external\n    onlyOwner\n{\n    isTxLimitExempt[holder] = exempt;\n}"
"function transfer(address recipient, uint256 amount)\n    external\n    override\n    returns (bool)\n{\n    return _transferFrom(msg.sender, recipient, amount);\n}"
"function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n) external override returns (bool) {\n    address spender = msg.sender;\n    //check allowance requirement\n    _spendAllowance(sender, spender, amount);\n    return _transferFrom(sender, recipient, amount);\n}"
"function _transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n) internal returns (bool) {\n    // make standard checks\n    require(\n        recipient != address(0) && recipient != address(this),\n        ""transfer to the zero address or CA""\n    );\n    require(amount > 0, ""Transfer amount must be greater than zero"");\n    require(\n        isTxLimitExempt[recipient] ||\n            _balances[recipient] + amount <= maxBag,\n        ""Max wallet exceeded!""\n    );\n\n    // subtract from sender\n    _balances[sender] = _balances[sender] - amount;\n\n    // give amount to receiver\n    _balances[recipient] = _balances[recipient] + amount;\n\n    // Transfer Event\n    emit Transfer(sender, recipient, amount);\n    return true;\n}"
"function _buy(uint256 minTokenOut, uint256 deadline)\n    public\n    payable\n    nonReentrant\n    returns (bool)\n{\n    // deadline requirement\n    require(deadline >= block.timestamp, ""Deadline EXPIRED"");\n\n    // Frontrun Guard\n    _lastBuyBlock[msg.sender] = block.number;\n\n    // liquidity is set\n    require(liquidity > 0, ""The token has no liquidity"");\n\n    // check if trading is open or whether the buying wallet is the migration one\n    require(\n        block.timestamp >= TRADE_OPEN_TIME ||\n            msg.sender == MIGRATION_WALLET,\n        ""Trading is not Open""\n    );\n\n    //remove the buy tax\n    uint256 bnbAmount = isFeeExempt[msg.sender]\n        ? msg.value\n        : (msg.value * buyMul) / DIVISOR;\n\n    // how much they should purchase?\n    uint256 tokensToSend = _balances[address(this)] -\n        (liqConst / (bnbAmount + liquidity));\n\n    //revert for max bag\n    require(\n        _balances[msg.sender] + tokensToSend <= maxBag ||\n            isTxLimitExempt[msg.sender],\n        ""Max wallet exceeded""\n    );\n\n    // revert if under 1\n    require(tokensToSend > 1, ""Must Buy more than 1 decimal of Surge"");\n\n    // revert for slippage\n    require(tokensToSend >= minTokenOut, ""INSUFFICIENT OUTPUT AMOUNT"");\n\n    // transfer the tokens from CA to the buyer\n    buy(msg.sender, tokensToSend);\n\n    //update available tax to extract and Liquidity\n    uint256 taxAmount = msg.value - bnbAmount;\n    taxBalance = taxBalance + taxAmount;\n    liquidity = liquidity + bnbAmount;\n\n    //update volume\n    uint256 cTime = block.timestamp;\n    uint256 dollarBuy = msg.value * getBNBPrice();\n    totalVolume += dollarBuy;\n    indVol[msg.sender] += dollarBuy;\n    tVol[cTime] += dollarBuy;\n\n    //update candleStickData\n    totalTx += 1;\n    txTimeStamp[totalTx] = cTime;\n    uint256 cPrice = calculatePrice() * getBNBPrice();\n    candleStickData[cTime].time = cTime;\n    if (candleStickData[cTime].open == 0) {\n        if (totalTx == 1) {\n            candleStickData[cTime].open =\n                ((liquidity - bnbAmount) / (_totalSupply)) *\n                getBNBPrice();\n        } else {\n            candleStickData[cTime].open = candleStickData[\n                txTimeStamp[totalTx - 1]\n            ].close;\n        }\n    }\n    candleStickData[cTime].close = cPrice;\n\n    if (\n        candleStickData[cTime].high < cPrice ||\n        candleStickData[cTime].high == 0\n    ) {\n        candleStickData[cTime].high = cPrice;\n    }\n\n    if (\n        candleStickData[cTime].low > cPrice ||\n        candleStickData[cTime].low == 0\n    ) {\n        candleStickData[cTime].low = cPrice;\n    }\n\n    //emit transfer and buy events\n    emit Transfer(address(this), msg.sender, tokensToSend);\n    emit Bought(\n        msg.sender,\n        address(this),\n        tokensToSend,\n        msg.value,\n        bnbAmount * getBNBPrice()\n    );\n    return true;\n}"
"function buy(address receiver, uint256 amount) internal {\n    _balances[receiver] = _balances[receiver] + amount;\n    _balances[address(this)] = _balances[address(this)] - amount;\n}"
"function _sell(\n    uint256 tokenAmount,\n    uint256 deadline,\n    uint256 minBNBOut\n) public nonReentrant returns (bool) {\n    // deadline requirement\n    require(deadline >= block.timestamp, ""Deadline EXPIRED"");\n\n    //Frontrun Guard\n    require(\n        _lastBuyBlock[msg.sender] != block.number,\n        ""Buying and selling in the same block is not allowed!""\n    );\n\n    address seller = msg.sender;\n\n    // make sure seller has this balance\n    require(\n        _balances[seller] >= tokenAmount,\n        ""cannot sell above token amount""\n    );\n\n    // get how much beans are the tokens worth\n    uint256 amountBNB = liquidity -\n        (liqConst / (_balances[address(this)] + tokenAmount));\n    uint256 amountTax = (amountBNB * (DIVISOR - sellMul)) / DIVISOR;\n    uint256 BNBToSend = amountBNB - amountTax;\n\n    //slippage revert\n    require(amountBNB >= minBNBOut, ""INSUFFICIENT OUTPUT AMOUNT"");\n\n    // send BNB to Seller\n    (bool successful, ) = isFeeExempt[msg.sender]\n        ? payable(seller).call{value: amountBNB}("""")\n        : payable(seller).call{value: BNBToSend}("""");\n    require(successful, ""BNB/ETH transfer failed"");\n\n    // subtract full amount from sender\n    _balances[seller] = _balances[seller] - tokenAmount;\n\n    //add tax allowance to be withdrawn and remove from liq the amount of beans taken by the seller\n    taxBalance = isFeeExempt[msg.sender]\n        ? taxBalance\n        : taxBalance + amountTax;\n    liquidity = liquidity - amountBNB;\n\n    // add tokens back into the contract\n    _balances[address(this)] = _balances[address(this)] + tokenAmount;\n\n    //update volume\n    uint256 cTime = block.timestamp;\n    uint256 dollarSell = amountBNB * getBNBPrice();\n    totalVolume += dollarSell;\n    indVol[msg.sender] += dollarSell;\n    tVol[cTime] += dollarSell;\n\n    //update candleStickData\n    totalTx += 1;\n    txTimeStamp[totalTx] = cTime;\n    uint256 cPrice = calculatePrice() * getBNBPrice();\n    candleStickData[cTime].time = cTime;\n    if (candleStickData[cTime].open == 0) {\n        candleStickData[cTime].open = candleStickData[\n            txTimeStamp[totalTx - 1]\n        ].close;\n    }\n    candleStickData[cTime].close = cPrice;\n\n    if (\n        candleStickData[cTime].high < cPrice ||\n        candleStickData[cTime].high == 0\n    ) {\n        candleStickData[cTime].high = cPrice;\n    }\n\n    if (\n        candleStickData[cTime].low > cPrice ||\n        candleStickData[cTime].low == 0\n    ) {\n        candleStickData[cTime].low = cPrice;\n    }\n\n    // emit transfer and sell events\n    emit Transfer(seller, address(this), tokenAmount);\n    if (isFeeExempt[msg.sender]) {\n        emit Sold(\n            address(this),\n            msg.sender,\n            tokenAmount,\n            amountBNB,\n            dollarSell\n        );\n    } else {\n        emit Sold(\n            address(this),\n            msg.sender,\n            tokenAmount,\n            BNBToSend,\n            BNBToSend * getBNBPrice()\n        );\n    }\n    return true;\n}"
function getLiquidity() public view returns (uint256) {\n    return liquidity;\n}
function getValueOfHoldings(address holder) public view returns (uint256) {\n    return\n        ((_balances[holder] * liquidity) / _balances[address(this)]) *\n        getBNBPrice();\n}
"function changeFees(uint256 newBuyMul, uint256 newSellMul)\n    external\n    onlyOwner\n{\n    require(\n        newBuyMul >= 90 &&\n            newSellMul >= 90 &&\n            newBuyMul <= 100 &&\n            newSellMul <= 100,\n        ""Fees are too high""\n    );\n\n    buyMul = newBuyMul;\n    sellMul = newSellMul;\n\n    emit FeesMulChanged(newBuyMul, newSellMul);\n}"
"function changeTaxDistribution(\n    uint256 newteamShare,\n    uint256 newtreasuryShare\n) external onlyOwner {\n    require(\n        newteamShare + newtreasuryShare == SHAREDIVISOR,\n        ""Sum of shares must be 100""\n    );\n\n    teamShare = newteamShare;\n    treasuryShare = newtreasuryShare;\n}"
"function changeFeeReceivers(\n    address newTeamWallet,\n    address newTreasuryWallet\n) external onlyOwner {\n    require(\n        newTeamWallet != address(0) && newTreasuryWallet != address(0),\n        ""New wallets must not be the ZERO address""\n    );\n\n    teamWallet = newTeamWallet;\n    treasuryWallet = newTreasuryWallet;\n}"
"function withdrawTaxBalance() external nonReentrant onlyOwner {\n    (bool temp1, ) = payable(teamWallet).call{\n        value: (taxBalance * teamShare) / SHAREDIVISOR\n    }("""");\n    (bool temp2, ) = payable(treasuryWallet).call{\n        value: (taxBalance * treasuryShare) / SHAREDIVISOR\n    }("""");\n    assert(temp1 && temp2);\n    taxBalance = 0;\n}"
function getTokenAmountOut(uint256 amountBNBIn)\n    external\n    view\n    returns (uint256)\n{\n    uint256 amountAfter = liqConst / (liquidity - amountBNBIn);\n    uint256 amountBefore = liqConst / liquidity;\n    return amountAfter - amountBefore;\n}
function getBNBAmountOut(uint256 amountIn) public view returns (uint256) {\n    uint256 beansBefore = liqConst / _balances[address(this)];\n    uint256 beansAfter = liqConst / (_balances[address(this)] + amountIn);\n    return beansBefore - beansAfter;\n}
"function addLiquidity() external payable onlyOwner {\n    uint256 tokensToAdd = (_balances[address(this)] * msg.value) /\n        liquidity;\n    require(_balances[msg.sender] >= tokensToAdd, ""Not enough tokens!"");\n\n    uint256 oldLiq = liquidity;\n    liquidity = liquidity + msg.value;\n    _balances[address(this)] += tokensToAdd;\n    _balances[msg.sender] -= tokensToAdd;\n    liqConst = (liqConst * liquidity) / oldLiq;\n\n    emit Transfer(msg.sender, address(this), tokensToAdd);\n}"
function getMarketCap() external view returns (uint256) {\n    return (getCirculatingSupply() * calculatePrice() * getBNBPrice());\n}
"function changeStablePair(address newStablePair, address newStableAddress)\n    external\n    onlyOwner\n{\n    require(\n        newStablePair != address(0) && newStableAddress != address(0),\n        ""New addresses must not be the ZERO address""\n    );\n\n    stablePairAddress = newStablePair;\n    stableAddress = newStableAddress;\n    emit StablePairChanged(newStablePair, newStableAddress);\n}"
"function getBNBPrice() public view returns (uint256) {\n    IPancakePair pair = IPancakePair(stablePairAddress);\n    IERC20 token1 = pair.token0() == stableAddress\n        ? IERC20(pair.token1())\n        : IERC20(pair.token0());\n\n    (uint256 Res0, uint256 Res1, ) = pair.getReserves();\n\n    if (pair.token0() != stableAddress) {\n        (Res1, Res0, ) = pair.getReserves();\n    }\n    uint256 res0 = Res0 * 10**token1.decimals();\n    return (res0 / Res1); // return amount of token0 needed to buy token1\n}"
"function calculatePrice() public view returns (uint256) {\n    require(liquidity > 0, ""No Liquidity"");\n    return liquidity / _balances[address(this)];\n}"
"constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals\n) {\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n\n    INITIAL_CHAIN_ID = block.chainid;\n    INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n}"
constructor() {\n  splitMain = ISplitMain(msg.sender);\n}
function sendETHToMain(uint256 amount) external payable onlySplitMain() {\n  address(splitMain).safeTransferETH(amount);\n}
"function sendERC20ToMain(ERC20 token, uint256 amount)\n  external\n  payable\n  onlySplitMain()\n{\n  token.safeTransfer(address(splitMain), amount);\n}"
"function clone(address implementation) internal returns (address instance) {\n  assembly {\n    let ptr := mload(0x40)\n    mstore(\n      ptr,\n      0x3d605d80600a3d3981f336603057343d52307f00000000000000000000000000\n    )\n    mstore(\n      add(ptr, 0x13),\n      0x830d2d700a97af574b186c80d40429385d24241565b08a7c559ba283a964d9b1\n    )\n    mstore(\n      add(ptr, 0x33),\n      0x60203da23d3df35b3d3d3d3d363d3d37363d7300000000000000000000000000\n    )\n    mstore(add(ptr, 0x46), shl(0x60, implementation))\n    mstore(\n      add(ptr, 0x5a),\n      0x5af43d3d93803e605b57fd5bf300000000000000000000000000000000000000\n    )\n    instance := create(0, ptr, 0x67)\n  }\n  if (instance == address(0)) revert CreateError();\n}"
"function cloneDeterministic(address implementation, bytes32 salt)\n  internal\n  returns (address instance)\n{\n  assembly {\n    let ptr := mload(0x40)\n    mstore(\n      ptr,\n      0x3d605d80600a3d3981f336603057343d52307f00000000000000000000000000\n    )\n    mstore(\n      add(ptr, 0x13),\n      0x830d2d700a97af574b186c80d40429385d24241565b08a7c559ba283a964d9b1\n    )\n    mstore(\n      add(ptr, 0x33),\n      0x60203da23d3df35b3d3d3d3d363d3d37363d7300000000000000000000000000\n    )\n    mstore(add(ptr, 0x46), shl(0x60, implementation))\n    mstore(\n      add(ptr, 0x5a),\n      0x5af43d3d93803e605b57fd5bf300000000000000000000000000000000000000\n    )\n    instance := create2(0, ptr, 0x67, salt)\n  }\n  if (instance == address(0)) revert Create2Error();\n}"
"function predictDeterministicAddress(\n  address implementation,\n  bytes32 salt,\n  address deployer\n) internal pure returns (address predicted) {\n  assembly {\n    let ptr := mload(0x40)\n    mstore(\n      ptr,\n      0x3d605d80600a3d3981f336603057343d52307f00000000000000000000000000\n    )\n    mstore(\n      add(ptr, 0x13),\n      0x830d2d700a97af574b186c80d40429385d24241565b08a7c559ba283a964d9b1\n    )\n    mstore(\n      add(ptr, 0x33),\n      0x60203da23d3df35b3d3d3d3d363d3d37363d7300000000000000000000000000\n    )\n    mstore(add(ptr, 0x46), shl(0x60, implementation))\n    mstore(\n      add(ptr, 0x5a),\n      0x5af43d3d93803e605b57fd5bf3ff000000000000000000000000000000000000\n    )\n    mstore(add(ptr, 0x68), shl(0x60, deployer))\n    mstore(add(ptr, 0x7c), salt)\n    mstore(add(ptr, 0x9c), keccak256(ptr, 0x67))\n    predicted := keccak256(add(ptr, 0x67), 0x55)\n  }\n}"
"function predictDeterministicAddress(address implementation, bytes32 salt)\n  internal\n  view\n  returns (address predicted)\n{\n  return predictDeterministicAddress(implementation, salt, address(this));\n}"
"function safeTransferETH(address to, uint256 amount) internal {\n    bool callStatus;\n\n    assembly {\n        // Transfer the ETH and store if it succeeded or not.\n        callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n    }\n\n    require(callStatus, ""ETH_TRANSFER_FAILED"");\n}"
"function safeTransferFrom(\n    ERC20 token,\n    address from,\n    address to,\n    uint256 amount\n) internal {\n    bool callStatus;\n\n    assembly {\n        // Get a pointer to some free memory.\n        let freeMemoryPointer := mload(0x40)\n\n        // Write the abi-encoded calldata to memory piece by piece:\n        mstore(\n            freeMemoryPointer,\n            0x23b872dd00000000000000000000000000000000000000000000000000000000\n        ) // Begin with the function selector.\n        mstore(\n            add(freeMemoryPointer, 4),\n            and(from, 0xffffffffffffffffffffffffffffffffffffffff)\n        ) // Mask and append the ""from"" argument.\n        mstore(\n            add(freeMemoryPointer, 36),\n            and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n        ) // Mask and append the ""to"" argument.\n        mstore(add(freeMemoryPointer, 68), amount) // Finally append the ""amount"" argument. No mask as it's a full 32 byte value.\n\n        // Call the token and store if it succeeded or not.\n        // We use 100 because the calldata length is 4 + 32 * 3.\n        callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n    }\n\n    require(\n        didLastOptionalReturnCallSucceed(callStatus),\n        ""TRANSFER_FROM_FAILED""\n    );\n}"
"function safeTransfer(ERC20 token, address to, uint256 amount) internal {\n    bool callStatus;\n\n    assembly {\n        // Get a pointer to some free memory.\n        let freeMemoryPointer := mload(0x40)\n\n        // Write the abi-encoded calldata to memory piece by piece:\n        mstore(\n            freeMemoryPointer,\n            0xa9059cbb00000000000000000000000000000000000000000000000000000000\n        ) // Begin with the function selector.\n        mstore(\n            add(freeMemoryPointer, 4),\n            and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n        ) // Mask and append the ""to"" argument.\n        mstore(add(freeMemoryPointer, 36), amount) // Finally append the ""amount"" argument. No mask as it's a full 32 byte value.\n\n        // Call the token and store if it succeeded or not.\n        // We use 68 because the calldata length is 4 + 32 * 2.\n        callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n    }\n\n    require(\n        didLastOptionalReturnCallSucceed(callStatus),\n        ""TRANSFER_FAILED""\n    );\n}"
"function safeApprove(ERC20 token, address to, uint256 amount) internal {\n    bool callStatus;\n\n    assembly {\n        // Get a pointer to some free memory.\n        let freeMemoryPointer := mload(0x40)\n\n        // Write the abi-encoded calldata to memory piece by piece:\n        mstore(\n            freeMemoryPointer,\n            0x095ea7b300000000000000000000000000000000000000000000000000000000\n        ) // Begin with the function selector.\n        mstore(\n            add(freeMemoryPointer, 4),\n            and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n        ) // Mask and append the ""to"" argument.\n        mstore(add(freeMemoryPointer, 36), amount) // Finally append the ""amount"" argument. No mask as it's a full 32 byte value.\n\n        // Call the token and store if it succeeded or not.\n        // We use 68 because the calldata length is 4 + 32 * 2.\n        callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n    }\n\n    require(didLastOptionalReturnCallSucceed(callStatus), ""APPROVE_FAILED"");\n}"
"function didLastOptionalReturnCallSucceed(\n    bool callStatus\n) private pure returns (bool success) {\n    assembly {\n        // Get how many bytes the call returned.\n        let returnDataSize := returndatasize()\n\n        // If the call reverted:\n        if iszero(callStatus) {\n            // Copy the revert message into memory.\n            returndatacopy(0, 0, returnDataSize)\n\n            // Revert with the same message.\n            revert(0, returnDataSize)\n        }\n\n        switch returnDataSize\n        case 32 {\n            // Copy the return data into memory.\n            returndatacopy(0, 0, returnDataSize)\n\n            // Set success to whether it returned true.\n            success := iszero(iszero(mload(0)))\n        }\n        case 0 {\n            // There was no return data.\n            success := 1\n        }\n        default {\n            // It returned some malformed input.\n            success := 0\n        }\n    }\n}"
constructor() {\n  walletImplementation = address(new SplitWallet());\n}
receive() external payable {}
"function createSplit(\n  address[] calldata accounts,\n  uint32[] calldata percentAllocations,\n  uint32 distributorFee,\n  address controller\n)\n  external\n  override\n  validSplit(accounts, percentAllocations, distributorFee)\n  returns (address split)\n{\n  bytes32 splitHash = _hashSplit(\n    accounts,\n    percentAllocations,\n    distributorFee\n  );\n  if (controller == address(0)) {\n    // create immutable split\n    split = Clones.cloneDeterministic(walletImplementation, splitHash);\n  } else {\n    // create mutable split\n    split = Clones.clone(walletImplementation);\n    splits[split].controller = controller;\n  }\n  // store split's hash in storage for future verification\n  splits[split].hash = splitHash;\n  emit CreateSplit(split);\n}"
"function predictImmutableSplitAddress(\n  address[] calldata accounts,\n  uint32[] calldata percentAllocations,\n  uint32 distributorFee\n)\n  external\n  view\n  override\n  validSplit(accounts, percentAllocations, distributorFee)\n  returns (address split)\n{\n  bytes32 splitHash = _hashSplit(\n    accounts,\n    percentAllocations,\n    distributorFee\n  );\n  split = Clones.predictDeterministicAddress(walletImplementation, splitHash);\n}"
"function updateSplit(\n  address split,\n  address[] calldata accounts,\n  uint32[] calldata percentAllocations,\n  uint32 distributorFee\n)\n  external\n  override\n  onlySplitController(split)\n  validSplit(accounts, percentAllocations, distributorFee)\n{\n  _updateSplit(split, accounts, percentAllocations, distributorFee);\n}"
"function transferControl(address split, address newController)\n  external\n  override\n  onlySplitController(split)\n  validNewController(newController)\n{\n  splits[split].newPotentialController = newController;\n  emit InitiateControlTransfer(split, newController);\n}"
function cancelControlTransfer(address split)\n  external\n  override\n  onlySplitController(split)\n{\n  delete splits[split].newPotentialController;\n  emit CancelControlTransfer(split);\n}
"function acceptControl(address split)\n  external\n  override\n  onlySplitNewPotentialController(split)\n{\n  delete splits[split].newPotentialController;\n  emit ControlTransfer(split, splits[split].controller, msg.sender);\n  splits[split].controller = msg.sender;\n}"
"function makeSplitImmutable(address split)\n  external\n  override\n  onlySplitController(split)\n{\n  delete splits[split].newPotentialController;\n  emit ControlTransfer(split, splits[split].controller, address(0));\n  splits[split].controller = address(0);\n}"
"function distributeETH(\n  address split,\n  address[] calldata accounts,\n  uint32[] calldata percentAllocations,\n  uint32 distributorFee,\n  address distributorAddress\n) external override validSplit(accounts, percentAllocations, distributorFee) {\n  // use internal fn instead of modifier to avoid stack depth compiler errors\n  _validSplitHash(split, accounts, percentAllocations, distributorFee);\n  _distributeETH(\n    split,\n    accounts,\n    percentAllocations,\n    distributorFee,\n    distributorAddress\n  );\n}"
"function updateAndDistributeETH(\n  address split,\n  address[] calldata accounts,\n  uint32[] calldata percentAllocations,\n  uint32 distributorFee,\n  address distributorAddress\n)\n  external\n  override\n  onlySplitController(split)\n  validSplit(accounts, percentAllocations, distributorFee)\n{\n  _updateSplit(split, accounts, percentAllocations, distributorFee);\n  // know splitHash is valid immediately after updating; only accessible via controller\n  _distributeETH(\n    split,\n    accounts,\n    percentAllocations,\n    distributorFee,\n    distributorAddress\n  );\n}"
"function distributeERC20(\n  address split,\n  ERC20 token,\n  address[] calldata accounts,\n  uint32[] calldata percentAllocations,\n  uint32 distributorFee,\n  address distributorAddress\n) external override validSplit(accounts, percentAllocations, distributorFee) {\n  // use internal fn instead of modifier to avoid stack depth compiler errors\n  _validSplitHash(split, accounts, percentAllocations, distributorFee);\n  _distributeERC20(\n    split,\n    token,\n    accounts,\n    percentAllocations,\n    distributorFee,\n    distributorAddress\n  );\n}"
"function updateAndDistributeERC20(\n  address split,\n  ERC20 token,\n  address[] calldata accounts,\n  uint32[] calldata percentAllocations,\n  uint32 distributorFee,\n  address distributorAddress\n)\n  external\n  override\n  onlySplitController(split)\n  validSplit(accounts, percentAllocations, distributorFee)\n{\n  _updateSplit(split, accounts, percentAllocations, distributorFee);\n  // know splitHash is valid immediately after updating; only accessible via controller\n  _distributeERC20(\n    split,\n    token,\n    accounts,\n    percentAllocations,\n    distributorFee,\n    distributorAddress\n  );\n}"
"function withdraw(\n  address account,\n  uint256 withdrawETH,\n  ERC20[] calldata tokens\n) external override {\n  uint256[] memory tokenAmounts = new uint256[](tokens.length);\n  uint256 ethAmount;\n  if (withdrawETH != 0) {\n    ethAmount = _withdraw(account);\n  }\n  unchecked {\n    // overflow should be impossible in for-loop index\n    for (uint256 i = 0; i < tokens.length; ++i) {\n      // overflow should be impossible in array length math\n      tokenAmounts[i] = _withdrawERC20(account, tokens[i]);\n    }\n    emit Withdrawal(account, ethAmount, tokens, tokenAmounts);\n  }\n}"
function getHash(address split) external view returns (bytes32) {\n  return splits[split].hash;\n}
function getController(address split) external view returns (address) {\n  return splits[split].controller;\n}
function getNewPotentialController(address split)\n  external\n  view\n  returns (address)\n{\n  return splits[split].newPotentialController;\n}
function getETHBalance(address account) external view returns (uint256) {\n  return\n    ethBalances[account] + (splits[account].hash != 0 ? account.balance : 0);\n}
"function getERC20Balance(address account, ERC20 token)\n  external\n  view\n  returns (uint256)\n{\n  return\n    erc20Balances[token][account] +\n    (splits[account].hash != 0 ? token.balanceOf(account) : 0);\n}"
function _getSum(uint32[] memory numbers) internal pure returns (uint32 sum) {\n  // overflow should be impossible in for-loop index\n  uint256 numbersLength = numbers.length;\n  for (uint256 i = 0; i < numbersLength; ) {\n    sum += numbers[i];\n    unchecked {\n      // overflow should be impossible in for-loop index\n      ++i;\n    }\n  }\n}
"function _hashSplit(\n  address[] memory accounts,\n  uint32[] memory percentAllocations,\n  uint32 distributorFee\n) internal pure returns (bytes32) {\n  return\n    keccak256(abi.encodePacked(accounts, percentAllocations, distributorFee));\n}"
"function _updateSplit(\n  address split,\n  address[] calldata accounts,\n  uint32[] calldata percentAllocations,\n  uint32 distributorFee\n) internal {\n  bytes32 splitHash = _hashSplit(\n    accounts,\n    percentAllocations,\n    distributorFee\n  );\n  // store new hash in storage for future verification\n  splits[split].hash = splitHash;\n  emit UpdateSplit(split);\n}"
"function _validSplitHash(\n  address split,\n  address[] memory accounts,\n  uint32[] memory percentAllocations,\n  uint32 distributorFee\n) internal view {\n  bytes32 hash = _hashSplit(accounts, percentAllocations, distributorFee);\n  if (splits[split].hash != hash) revert InvalidSplit__InvalidHash(hash);\n}"
"function _distributeETH(\n  address split,\n  address[] memory accounts,\n  uint32[] memory percentAllocations,\n  uint32 distributorFee,\n  address distributorAddress\n) internal {\n  uint256 mainBalance = ethBalances[split];\n  uint256 proxyBalance = split.balance;\n  // if mainBalance is positive, leave 1 in SplitMain for gas efficiency\n  uint256 amountToSplit;\n  unchecked {\n    // underflow should be impossible\n    if (mainBalance > 0) mainBalance -= 1;\n    // overflow should be impossible\n    amountToSplit = mainBalance + proxyBalance;\n  }\n  if (mainBalance > 0) ethBalances[split] = 1;\n  // emit event with gross amountToSplit (before deducting distributorFee)\n  emit DistributeETH(split, amountToSplit, distributorAddress);\n  if (distributorFee != 0) {\n    // given `amountToSplit`, calculate keeper fee\n    uint256 distributorFeeAmount = _scaleAmountByPercentage(\n      amountToSplit,\n      distributorFee\n    );\n    unchecked {\n      // credit keeper with fee\n      // overflow should be impossible with validated distributorFee\n      ethBalances[\n        distributorAddress != address(0) ? distributorAddress : msg.sender\n      ] += distributorFeeAmount;\n      // given keeper fee, calculate how much to distribute to split recipients\n      // underflow should be impossible with validated distributorFee\n      amountToSplit -= distributorFeeAmount;\n    }\n  }\n  unchecked {\n    // distribute remaining balance\n    // overflow should be impossible in for-loop index\n    // cache accounts length to save gas\n    uint256 accountsLength = accounts.length;\n    for (uint256 i = 0; i < accountsLength; ++i) {\n      // overflow should be impossible with validated allocations\n      ethBalances[accounts[i]] += _scaleAmountByPercentage(\n        amountToSplit,\n        percentAllocations[i]\n      );\n    }\n  }\n  // flush proxy ETH balance to SplitMain\n  // split proxy should be guaranteed to exist at this address after validating splitHash\n  // (attacker can't deploy own contract to address with high balance & empty sendETHToMain\n  // to drain ETH from SplitMain)\n  // could technically check if (change in proxy balance == change in SplitMain balance)\n  // before/after external call, but seems like extra gas for no practical benefit\n  if (proxyBalance > 0) SplitWallet(split).sendETHToMain(proxyBalance);\n}"
"function _distributeERC20(\n  address split,\n  ERC20 token,\n  address[] memory accounts,\n  uint32[] memory percentAllocations,\n  uint32 distributorFee,\n  address distributorAddress\n) internal {\n  uint256 amountToSplit;\n  uint256 mainBalance = erc20Balances[token][split];\n  uint256 proxyBalance = token.balanceOf(split);\n  unchecked {\n    // if mainBalance &/ proxyBalance are positive, leave 1 for gas efficiency\n    // underflow should be impossible\n    if (proxyBalance > 0) proxyBalance -= 1;\n    // underflow should be impossible\n    if (mainBalance > 0) {\n      mainBalance -= 1;\n    }\n    // overflow should be impossible\n    amountToSplit = mainBalance + proxyBalance;\n  }\n  if (mainBalance > 0) erc20Balances[token][split] = 1;\n  // emit event with gross amountToSplit (before deducting distributorFee)\n  emit DistributeERC20(split, token, amountToSplit, distributorAddress);\n  if (distributorFee != 0) {\n    // given `amountToSplit`, calculate keeper fee\n    uint256 distributorFeeAmount = _scaleAmountByPercentage(\n      amountToSplit,\n      distributorFee\n    );\n    // overflow should be impossible with validated distributorFee\n    unchecked {\n      // credit keeper with fee\n      erc20Balances[token][\n        distributorAddress != address(0) ? distributorAddress : msg.sender\n      ] += distributorFeeAmount;\n      // given keeper fee, calculate how much to distribute to split recipients\n      amountToSplit -= distributorFeeAmount;\n    }\n  }\n  // distribute remaining balance\n  // overflows should be impossible in for-loop with validated allocations\n  unchecked {\n    // cache accounts length to save gas\n    uint256 accountsLength = accounts.length;\n    for (uint256 i = 0; i < accountsLength; ++i) {\n      erc20Balances[token][accounts[i]] += _scaleAmountByPercentage(\n        amountToSplit,\n        percentAllocations[i]\n      );\n    }\n  }\n  // split proxy should be guaranteed to exist at this address after validating splitHash\n  // (attacker can't deploy own contract to address with high ERC20 balance & empty\n  // sendERC20ToMain to drain ERC20 from SplitMain)\n  // doesn't support rebasing or fee-on-transfer tokens\n  // flush extra proxy ERC20 balance to SplitMain\n  if (proxyBalance > 0)\n    SplitWallet(split).sendERC20ToMain(token, proxyBalance);\n}"
"function _scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)\n  internal\n  pure\n  returns (uint256 scaledAmount)\n{\n  // use assembly to bypass checking for overflow & division by 0\n  // scaledPercent has been validated to be < PERCENTAGE_SCALE)\n  // & PERCENTAGE_SCALE will never be 0\n  // pernicious ERC20s may cause overflow, but results do not affect ETH & other ERC20 balances\n  assembly {\n    /* eg (100 * 2*1e4) / (1e6) */\n    scaledAmount := div(mul(amount, scaledPercent), PERCENTAGE_SCALE)\n  }\n}"
function _withdraw(address account) internal returns (uint256 withdrawn) {\n  // leave balance of 1 for gas efficiency\n  // underflow if ethBalance is 0\n  withdrawn = ethBalances[account] - 1;\n  ethBalances[account] = 1;\n  account.safeTransferETH(withdrawn);\n}
"function _withdrawERC20(address account, ERC20 token)\n  internal\n  returns (uint256 withdrawn)\n{\n  // leave balance of 1 for gas efficiency\n  // underflow if erc20Balance is 0\n  withdrawn = erc20Balances[token][account] - 1;\n  erc20Balances[token][account] = 1;\n  token.safeTransfer(account, withdrawn);\n}"
"function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n\n    uint256 size;\n    assembly {\n        size := extcodesize(account)\n    }\n    return size > 0;\n}"
"function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n    (bool success, ) = recipient.call{value: amount}("""");\n    require(success, ""Address: unable to send value, recipient may have reverted"");\n}"
"function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, ""Address: low-level call failed"");\n}"
"function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(address(this).balance >= value, ""Address: insufficient balance for call"");\n    require(isContract(target), ""Address: call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, ""Address: low-level static call failed"");\n}"
"function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal view returns (bytes memory) {\n    require(isContract(target), ""Address: static call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n}"
"function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(isContract(target), ""Address: delegate call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n) internal pure returns (bytes memory) {\n    if (success) {\n        return returndata;\n    } else {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}"
"function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n}"
"function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n}"
"function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n        (value == 0) || (token.allowance(address(this), spender) == 0),\n        ""SafeERC20: approve from non-zero to non-zero allowance""\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n}"
"function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n}"
"function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n) internal {\n    unchecked {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        require(oldAllowance >= value, ""SafeERC20: decreased allowance below zero"");\n        uint256 newAllowance = oldAllowance - value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n}"
"function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");\n    if (returndata.length > 0) {\n        // Return data is optional\n        require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");\n    }\n}"
"constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}"
constructor() {\n    _setOwner(_msgSender());\n}
"function _setOwner(address newOwner) private {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n}"
"function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n        return ""0"";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n        digits++;\n        temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n        digits -= 1;\n        buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n        value /= 10;\n    }\n    return string(buffer);\n}"
"function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n        return ""0x00"";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n        length++;\n        temp >>= 8;\n    }\n    return toHexString(value, length);\n}"
"function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = ""0"";\n    buffer[1] = ""x"";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n        buffer[i] = _HEX_SYMBOLS[value & 0xf];\n        value >>= 4;\n    }\n    require(value == 0, ""Strings: hex length insufficient"");\n    return string(buffer);\n}"
"function hasRole(bytes32 role, address account) public view override returns (bool) {\n    return _roles[role].members[account];\n}"
"function _checkRole(bytes32 role, address account) internal view {\n    if (!hasRole(role, account)) {\n        revert(\n            string(\n                abi.encodePacked(\n                    ""AccessControl: account "",\n                    Strings.toHexString(uint160(account), 20),\n                    "" is missing role "",\n                    Strings.toHexString(uint256(role), 32)\n                )\n            )\n        );\n    }\n}"
function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n    return _roles[role].adminRole;\n}
"function _grantRole(bytes32 role, address account) private {\n    if (!hasRole(role, account)) {\n        _roles[role].members[account] = true;\n        emit RoleGranted(role, account, _msgSender());\n    }\n}"
"function _revokeRole(bytes32 role, address account) private {\n    if (hasRole(role, account)) {\n        _roles[role].members[account] = false;\n        emit RoleRevoked(role, account, _msgSender());\n    }\n}"
"constructor(\n    bytes4 source_,\n    bytes32 sourceAddress_,\n    uint8 decimals_,\n    string memory name,\n    string memory symbol\n) ERC20(name, symbol) {\n    source = source_;\n    sourceAddress = sourceAddress_;\n    _decimals = decimals_;\n}"
"function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n}"
"function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n}"
"function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n}"
"function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a / b + (a % b == 0 ? 0 : 1);\n}"
constructor(IERC20 _ABR) {\n    ABR = _ABR;\n}
"function deposit(uint256 _amount) public {\n    // Gets the amount of ABR locked in the contract\n    uint256 totalABR = ABR.balanceOf(address(this));\n    // Gets the amount of xABR in existence\n    uint256 totalShares = totalSupply();\n    // If no xABR exists, mint it 1:1 to the amount put in\n    if (totalShares == 0 || totalABR == 0) {\n        _mint(msg.sender, _amount);\n    }\n    // Calculate and mint the amount of xABR the ABR is worth. The ratio will change overtime, \n    // as xABR is burned/minted and ABR deposited + gained from fees / withdrawn.\n    else {\n        uint256 what = _amount * totalShares / totalABR;\n        _mint(msg.sender, what);\n    }\n    // Lock the ABR in the contract\n    ABR.transferFrom(msg.sender, address(this), _amount);\n}"
"function withdraw(uint256 _share) public {\n    // Gets the amount of xABR in existence\n    uint256 totalShares = totalSupply();\n    // Calculates the amount of ABR the xABR is worth\n    uint256 what = _share * ABR.balanceOf(address(this)) / totalShares;\n    _burn(msg.sender, _share);\n    ABR.transfer(msg.sender, what);\n}"
"constructor(IERC20 xABR_, uint256 baseFeeRateBP_, uint256 feeMultiplier_) {\n    xABR = xABR_;\n    baseFeeRateBP = baseFeeRateBP_;\n    feeMultiplier = feeMultiplier_;\n}"
function setFeeMultiplier(uint256 multiplier) public onlyOwner {\n    feeMultiplier = multiplier;\n}
"function setMinFee(address token, uint256 _minFee) public onlyOwner {\n    minFee[token] = _minFee;\n}"
function setBaseFeeRate(uint256 baseFeeRateBP_) public onlyOwner {\n    baseFeeRateBP = baseFeeRateBP_;\n}
"function fee(address token, address sender, uint256 amount, bytes4) public view returns (uint256) {\n    uint256 _minFee = minFee[token];\n    if (xABR.totalSupply() == 0 || baseFeeRateBP == 0 || amount == 0) {\n        return _minFee;\n    }\n    uint256 userShareBP = xABR.balanceOf(sender) * feeMultiplier * BP / xABR.totalSupply();\n\n    uint256 result = (amount * BP) / (userShareBP + (BP * BP / baseFeeRateBP));\n    if (_minFee > 0 && result < _minFee) {\n        return _minFee;\n    } else {\n        return result;\n    }\n}"
"constructor(\n    address feeCollector_,\n    address admin_,\n    address validator_,\n    address feeOracle_,\n    address unlockSigner_\n) {\n    feeCollector = feeCollector_;\n    validator = validator_;\n    feeOracle = feeOracle_;\n    _setupRole(DEFAULT_ADMIN_ROLE, admin_);\n    unlockSigner = unlockSigner_;\n    active = false;\n}"
"function lock(\n    uint128 lockId,\n    address tokenAddress,\n    bytes32 recipient,\n    bytes4 destination,\n    uint256 amount\n) external isActive {\n    (uint256 amountToLock, uint256 fee, TokenInfo memory tokenInfo) = _createLock(\n        lockId,\n        tokenAddress,\n        amount,\n        recipient,\n        destination\n    );\n\n    require(tokenInfo.tokenStatus == TokenStatus.Enabled, ""Bridge: disabled token"");\n\n    if (tokenInfo.tokenType == TokenType.Native) {\n        // If token is native - transfer tokens from user to contract\n        IERC20(tokenAddress).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountToLock\n        );\n    } else if (tokenInfo.tokenType == TokenType.Wrapped) {\n        // If wrapped then butn the token\n        WrappedToken(tokenAddress).burn(msg.sender, amountToLock);\n    } else if (tokenInfo.tokenType == TokenType.WrappedV0) {\n        // Legacy wrapped tokens burn\n        IWrappedTokenV0(tokenAddress).burn(msg.sender, amountToLock);\n    } else {\n        revert(""Bridge: invalid token type"");\n    }\n\n    if (fee > 0) {\n        // If there is fee - transfer it to fee collector address\n        IERC20(tokenAddress).safeTransferFrom(\n            msg.sender,\n            feeCollector,\n            fee\n        );\n    }\n}"
"function lockBase(\n    uint128 lockId, \n    address wrappedBaseTokenAddress, \n    bytes32 recipient, \n    bytes4 destination) external payable isActive {\n    (, uint256 fee, TokenInfo memory tokenInfo) = _createLock(\n        lockId,\n        wrappedBaseTokenAddress,\n        msg.value,\n        recipient,\n        destination\n    );\n\n    require(tokenInfo.tokenStatus == TokenStatus.Enabled, ""Bridge: disabled token"");\n    require(tokenInfo.tokenType == TokenType.Base, ""Bridge: invalid token type"");\n\n    if (fee > 0) {\n        // If there is fee - transfer ETH to fee collector address\n        payable(feeCollector).transfer(fee);\n    }\n}"
"function unlock(\n    uint128 lockId,\n    address recipient, uint256 amount,\n    bytes4 lockSource, bytes4 tokenSource,\n    bytes32 tokenSourceAddress,\n    bytes calldata signature) external isActive {\n    // Create message hash and validate the signature\n    IValidator(validator).createUnlock(\n            lockId,\n            recipient,\n            amount,\n            lockSource,\n            tokenSource,\n            tokenSourceAddress,\n            signature);\n\n    // Mark lock as received\n    address tokenAddress = tokenSourceMap[tokenSource][tokenSourceAddress];\n    require(tokenAddress != address(0), ""Bridge: unsupported token"");\n    TokenInfo memory tokenInfo = tokenInfos[tokenAddress];\n\n    // Transform amount form system to token precision\n    uint256 amountWithTokenPrecision = fromSystemPrecision(amount, tokenInfo.precision);\n    uint256 fee = 0;\n    if (msg.sender == unlockSigner) {\n        fee = FeeOracle(feeOracle).minFee(tokenAddress);\n        require(amountWithTokenPrecision > fee, ""Bridge: amount too small"");\n        amountWithTokenPrecision = amountWithTokenPrecision - fee;\n    }\n\n    if (tokenInfo.tokenType == TokenType.Base) {\n        // If token is WETH - transfer ETH\n        payable(recipient).transfer(amountWithTokenPrecision);\n        if (fee > 0) {\n            payable(feeCollector).transfer(fee);\n        }\n    } else if (tokenInfo.tokenType == TokenType.Native) {\n        // If token is native - transfer the token\n        IERC20(tokenAddress).safeTransfer(recipient, amountWithTokenPrecision);\n        if (fee > 0) {\n            IERC20(tokenAddress).safeTransfer(feeCollector, fee);\n        }\n    } else if (tokenInfo.tokenType == TokenType.Wrapped) {\n        // Else token is wrapped - mint tokens to the user\n        WrappedToken(tokenAddress).mint(recipient, amountWithTokenPrecision);\n        if (fee > 0) {\n            WrappedToken(tokenAddress).mint(feeCollector, fee);\n        }\n    } else if (tokenInfo.tokenType == TokenType.WrappedV0) {\n        // Legacy wrapped token\n        IWrappedTokenV0(tokenAddress).mint(recipient, amountWithTokenPrecision);\n        if (fee > 0) {\n            IWrappedTokenV0(tokenAddress).mint(feeCollector, fee);\n        }\n    }\n\n    emit Received(recipient, tokenAddress, amountWithTokenPrecision, lockId, lockSource);\n}"
"function addToken(\n    bytes4 tokenSource, \n    bytes32 tokenSourceAddress, \n    address nativeTokenAddress, \n    TokenType tokenType) external onlyRole(TOKEN_MANAGER) {\n    require(\n        tokenInfos[nativeTokenAddress].tokenSourceAddress == bytes32(0) &&\n        tokenSourceMap[tokenSource][tokenSourceAddress] == address(0), ""Bridge: exists"");\n    uint8 precision = ERC20(nativeTokenAddress).decimals();\n\n    tokenSourceMap[tokenSource][tokenSourceAddress] = nativeTokenAddress;\n    tokenInfos[nativeTokenAddress] = TokenInfo(\n        tokenSource, \n        tokenSourceAddress, \n        precision, \n        tokenType, \n        TokenStatus.Enabled);\n}"
"function removeToken(\n    bytes4 tokenSource, \n    bytes32 tokenSourceAddress, \n    address newAuthority) external onlyRole(TOKEN_MANAGER) {\n    require(newAuthority != address(0), ""Bridge: zero address authority"");\n    address tokenAddress = tokenSourceMap[tokenSource][tokenSourceAddress];\n    require(tokenAddress != address(0), ""Bridge: token not found"");\n    TokenInfo memory tokenInfo = tokenInfos[tokenAddress];\n\n    if (tokenInfo.tokenType == TokenType.Base && address(this).balance > 0) {\n        payable(newAuthority).transfer(address(this).balance);\n    }\n\n    uint256 tokenBalance = IERC20(tokenAddress).balanceOf(address(this));\n    if (tokenBalance > 0) {\n        IERC20(tokenAddress).safeTransfer(newAuthority, tokenBalance);\n    }\n\n    if (tokenInfo.tokenType == TokenType.Wrapped) {\n        WrappedToken(tokenAddress).transferOwnership(newAuthority);\n    } else if (tokenInfo.tokenType == TokenType.WrappedV0) {\n        IWrappedTokenV0(tokenAddress).changeAuthority(newAuthority);\n    }\n\n    delete tokenInfos[tokenAddress];\n    delete tokenSourceMap[tokenSource][tokenSourceAddress];\n}"
function setFeeOracle(address _feeOracle) external onlyRole(TOKEN_MANAGER) {\n    feeOracle = _feeOracle;\n}
function setFeeCollector(address _feeCollector) external onlyRole(TOKEN_MANAGER) {\n    feeCollector = _feeCollector;\n}
function setValidator(address _validator ) external onlyRole(BRIDGE_MANAGER) {\n    validator = _validator;\n}
function setUnlockSigner(address _unlockSigner ) external onlyRole(BRIDGE_MANAGER) {\n    unlockSigner = _unlockSigner;\n}
"function setTokenStatus(address tokenAddress, TokenStatus status)  external onlyRole(TOKEN_MANAGER) {\n    require(tokenInfos[tokenAddress].tokenSourceAddress != bytes32(0), ""Bridge: unsupported token"");\n    tokenInfos[tokenAddress].tokenStatus = status;\n}"
function startBridge() external onlyRole(BRIDGE_MANAGER) {\n    active = true;\n}
function stopBridge() external onlyRole(STOP_MANAGER) {\n    active = false;\n}
"function _createLock(\n    uint128 lockId,\n    address tokenAddress,\n    uint256 amount,\n    bytes32 recipient,\n    bytes4 destination\n) private returns (uint256, uint256, TokenInfo memory) {\n    require(amount > 0, ""Bridge: amount is 0"");\n    TokenInfo memory tokenInfo = tokenInfos[tokenAddress];\n    require(\n        tokenInfo.tokenSourceAddress != bytes32(0),\n        ""Bridge: unsupported token""\n    );\n\n    uint256 fee = FeeOracle(feeOracle).fee(tokenAddress, msg.sender, amount, destination);\n\n    require(amount > fee, ""Bridge: amount too small"");\n\n    // Amount to lock is amount without fee\n    uint256 amountToLock = amount - fee;\n\n    // Create and add lock structure to the locks list\n    IValidator(validator).createLock(\n        lockId,\n        msg.sender,\n        recipient,\n        toSystemPrecision(amountToLock, tokenInfo.precision),\n        destination,\n        tokenInfo.tokenSource,\n        tokenInfo.tokenSourceAddress\n    );\n\n    emit Sent(\n        tokenInfo.tokenSource,\n        tokenInfo.tokenSourceAddress,\n        msg.sender,\n        recipient,\n        amountToLock,\n        lockId,\n        destination\n    );\n    return (amountToLock, fee, tokenInfo);\n}"
"function toSystemPrecision(uint256 amount, uint8 precision)\n    private\n    pure\n    returns (uint256)\n{\n    if (precision > SYSTEM_PRECISION) {\n        return amount / (10**(precision - SYSTEM_PRECISION));\n    } else if (precision < SYSTEM_PRECISION) {\n        return amount * (10**(SYSTEM_PRECISION - precision));\n    } else {\n        return amount;\n    }\n}"
"function fromSystemPrecision(uint256 amount, uint8 precision)\n    private\n    pure\n    returns (uint256)\n{\n    if (precision > SYSTEM_PRECISION) {\n        return amount * (10**(precision - SYSTEM_PRECISION));\n    } else if (precision < SYSTEM_PRECISION) {\n        return amount / (10**(SYSTEM_PRECISION - precision));\n    } else {\n        return amount;\n    }\n}"
"function tryAdd(\n    uint256 a,\n    uint256 b\n) internal pure returns (bool, uint256) {\n    unchecked {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n}"
"function trySub(\n    uint256 a,\n    uint256 b\n) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n}"
"function tryMul(\n    uint256 a,\n    uint256 b\n) internal pure returns (bool, uint256) {\n    unchecked {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n}"
"function tryDiv(\n    uint256 a,\n    uint256 b\n) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n}"
"function tryMod(\n    uint256 a,\n    uint256 b\n) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n}"
"function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n}"
"function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n}"
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n}"
"function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n}"
"function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a % b;\n}"
"function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n}"
"function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n}"
"function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    unchecked {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}"
"constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}"
constructor() {\n    _transferOwnership(_msgSender());\n}
"constructor() ERC20(""Andy"", ""ANDY"") {\n    IDexRouter _dexRouter = IDexRouter(\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n    );\n\n    exemptFromLimits(address(_dexRouter), true);\n    dexRouter = _dexRouter;\n\n    dexPair = IDexFactory(_dexRouter.factory()).createPair(\n        address(this),\n        _dexRouter.WETH()\n    );\n    exemptFromLimits(address(dexPair), true);\n    _setAutomatedMarketMakerPair(address(dexPair), true);\n\n    uint256 _buyMarketingTax = 20;\n    uint256 _buyProjectTax = 0;\n\n    uint256 _sellMarketingTax = 20;\n    uint256 _sellProjectTax = 0;\n\n    uint256 _totalSupply = 1_000_000_000_000 * 10 ** decimals();\n\n    maxTx = (_totalSupply * 10) / 1000;\n    maxWallet = (_totalSupply * 10) / 1000;\n\n    swapBackValueMin = (_totalSupply * 1) / 1000;\n    swapBackValueMax = (_totalSupply * 2) / 100;\n\n    buyMarketingTax = _buyMarketingTax;\n    buyProjectTax = _buyProjectTax;\n    buyTaxTotal = buyMarketingTax + buyProjectTax;\n\n    sellMarketingTax = _sellMarketingTax;\n    sellProjectTax = _sellProjectTax;\n    sellTaxTotal = sellMarketingTax + sellProjectTax;\n\n    marketingWallet = address(0xb30Fa23184D080fa7631b9eC13C7F58eb5B00Ae0);\n    projectWallet = address(msg.sender);\n\n    // exclude from paying fees or having max transaction amount\n    exemptFromFees(msg.sender, true);\n    exemptFromFees(address(this), true);\n    exemptFromFees(address(0xdead), true);\n    exemptFromFees(marketingWallet, true);\n\n    exemptFromLimits(msg.sender, true);\n    exemptFromLimits(address(this), true);\n    exemptFromLimits(address(0xdead), true);\n    exemptFromLimits(marketingWallet, true);\n\n    transferOwnership(msg.sender);\n\n    /*\n        _mint is an internal function in ERC20.sol that is only called here,\n        and CANNOT be called ever again\n    */\n    _mint(msg.sender, _totalSupply);\n}"
receive() external payable {}
function startTrading() external onlyOwner {\n    tradingEnabled = true;\n    swapbackEnabled = true;\n    emit TradingEnabled(block.timestamp);\n}
function removeAllLimits() external onlyOwner {\n    limitsEnabled = false;\n    emit LimitsRemoved(block.timestamp);\n}
function disableTransferDelay() external onlyOwner {\n    transferDelayEnabled = false;\n    emit DisabledTransferDelay(block.timestamp);\n}
"function setSwapBackSettings(\n    bool _enabled,\n    uint256 _min,\n    uint256 _max\n) external onlyOwner {\n    require(\n        _min >= 1,\n        ""Swap amount cannot be lower than 0.01% total supply.""\n    );\n    require(_max >= _min, ""maximum amount cant be higher than minimum"");\n\n    swapbackEnabled = _enabled;\n    swapBackValueMin = (totalSupply() * _min) / 10000;\n    swapBackValueMax = (totalSupply() * _max) / 10000;\n    emit SwapbackSettingsUpdated(_enabled, _min, _max);\n}"
"function setTheMaxTx(uint256 newNum) external onlyOwner {\n    require(newNum >= 2, ""Cannot set maxTx lower than 0.2%"");\n    maxTx = (newNum * totalSupply()) / 1000;\n    emit MaxTxUpdated(maxTx);\n}"
"function setTheMaxWallet(uint256 newNum) external onlyOwner {\n    require(newNum >= 5, ""Cannot set maxWallet lower than 0.5%"");\n    maxWallet = (newNum * totalSupply()) / 1000;\n    emit MaxWalletUpdated(maxWallet);\n}"
"function exemptFromLimits(\n    address updAds,\n    bool isEx\n) public onlyOwner {\n    transferLimitExempt[updAds] = isEx;\n    emit ExcludeFromLimits(updAds, isEx);\n}"
"function setFeesBuy(\n    uint256 _marketingFee,\n    uint256 _devFee\n) external onlyOwner {\n    buyMarketingTax = _marketingFee;\n    buyProjectTax = _devFee;\n    buyTaxTotal = buyMarketingTax + buyProjectTax;\n    require(buyTaxTotal <= 100, ""Total buy fee cannot be higher than 100%"");\n    emit BuyFeeUpdated(buyTaxTotal, buyMarketingTax, buyProjectTax);\n}"
"function setFeesSell(\n    uint256 _marketingFee,\n    uint256 _devFee\n) external onlyOwner {\n    sellMarketingTax = _marketingFee;\n    sellProjectTax = _devFee;\n    sellTaxTotal = sellMarketingTax + sellProjectTax;\n    require(\n        sellTaxTotal <= 100,\n        ""Total sell fee cannot be higher than 100%""\n    );\n    emit SellFeeUpdated(sellTaxTotal, sellMarketingTax, sellProjectTax);\n}"
"function exemptFromFees(address account, bool excluded) public onlyOwner {\n    transferTaxExempt[account] = excluded;\n    emit ExcludeFromFees(account, excluded);\n}"
"function setAutomatedMarketMakerPair(\n    address pair,\n    bool value\n) public onlyOwner {\n    require(\n        pair != dexPair,\n        ""The pair cannot be removed from automatedMarketMakerPairs""\n    );\n\n    _setAutomatedMarketMakerPair(pair, value);\n}"
"function _setAutomatedMarketMakerPair(address pair, bool value) private {\n    automatedMarketMakerPairs[pair] = value;\n\n    emit SetAutomatedMarketMakerPair(pair, value);\n}"
"function changeMarketingWallet(address newWallet) external onlyOwner {\n    emit MarketingWalletUpdated(newWallet, marketingWallet);\n    marketingWallet = newWallet;\n}"
"function changeProjectWallet(address newWallet) external onlyOwner {\n    emit ProjectWalletUpdated(newWallet, projectWallet);\n    projectWallet = newWallet;\n}"
"function swapbackValues()\n    external\n    view\n    returns (\n        bool _swapbackEnabled,\n        uint256 _swapBackValueMin,\n        uint256 _swapBackValueMax\n    )\n{\n    _swapbackEnabled = swapbackEnabled;\n    _swapBackValueMin = swapBackValueMin;\n    _swapBackValueMax = swapBackValueMax;\n}"
"function maxTxValues()\n    external\n    view\n    returns (\n        bool _limitsEnabled,\n        bool _transferDelayEnabled,\n        uint256 _maxWallet,\n        uint256 _maxTx\n    )\n{\n    _limitsEnabled = limitsEnabled;\n    _transferDelayEnabled = transferDelayEnabled;\n    _maxWallet = maxWallet;\n    _maxTx = maxTx;\n}"
"function receiverwallets()\n    external\n    view\n    returns (address _marketingWallet, address _projectWallet)\n{\n    return (marketingWallet, projectWallet);\n}"
"function taxValues()\n    external\n    view\n    returns (\n        uint256 _buyTaxTotal,\n        uint256 _buyMarketingTax,\n        uint256 _buyProjectTax,\n        uint256 _sellTaxTotal,\n        uint256 _sellMarketingTax,\n        uint256 _sellProjectTax\n    )\n{\n    _buyTaxTotal = buyTaxTotal;\n    _buyMarketingTax = buyMarketingTax;\n    _buyProjectTax = buyProjectTax;\n    _sellTaxTotal = sellTaxTotal;\n    _sellMarketingTax = sellMarketingTax;\n    _sellProjectTax = sellProjectTax;\n}"
"function checkMappings(\n    address _target\n)\n    external\n    view\n    returns (\n        bool _transferTaxExempt,\n        bool _transferLimitExempt,\n        bool _automatedMarketMakerPairs\n    )\n{\n    _transferTaxExempt = transferTaxExempt[_target];\n    _transferLimitExempt = transferLimitExempt[_target];\n    _automatedMarketMakerPairs = automatedMarketMakerPairs[_target];\n}"
"function _transfer(\n    address from,\n    address to,\n    uint256 amount\n) internal override {\n    require(from != address(0), ""ERC20: transfer from the zero address"");\n    require(to != address(0), ""ERC20: transfer to the zero address"");\n\n    if (amount == 0) {\n        super._transfer(from, to, 0);\n        return;\n    }\n\n    if (limitsEnabled) {\n        if (\n            from != owner() &&\n            to != owner() &&\n            to != address(0) &&\n            to != address(0xdead) &&\n            !swapping\n        ) {\n            if (!tradingEnabled) {\n                require(\n                    transferTaxExempt[from] || transferTaxExempt[to],\n                    ""_transfer:: Trading is not active.""\n                );\n            }\n\n            // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.\n            if (transferDelayEnabled) {\n                if (\n                    to != owner() &&\n                    to != address(dexRouter) &&\n                    to != address(dexPair)\n                ) {\n                    require(\n                        _holderLastTransferTimestamp[tx.origin] <\n                            block.number,\n                        ""_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.""\n                    );\n                    _holderLastTransferTimestamp[tx.origin] = block.number;\n                }\n            }\n\n            //when buy\n            if (\n                automatedMarketMakerPairs[from] && !transferLimitExempt[to]\n            ) {\n                require(\n                    amount <= maxTx,\n                    ""Buy transfer amount exceeds the maxTx.""\n                );\n                require(\n                    amount + balanceOf(to) <= maxWallet,\n                    ""Max wallet exceeded""\n                );\n            }\n            //when sell\n            else if (\n                automatedMarketMakerPairs[to] && !transferLimitExempt[from]\n            ) {\n                require(\n                    amount <= maxTx,\n                    ""Sell transfer amount exceeds the maxTx.""\n                );\n            } else if (!transferLimitExempt[to]) {\n                require(\n                    amount + balanceOf(to) <= maxWallet,\n                    ""Max wallet exceeded""\n                );\n            }\n        }\n    }\n\n    uint256 contractTokenBalance = balanceOf(address(this));\n\n    bool canSwap = contractTokenBalance >= swapBackValueMin;\n\n    if (\n        canSwap &&\n        swapbackEnabled &&\n        !swapping &&\n        !automatedMarketMakerPairs[from] &&\n        !transferTaxExempt[from] &&\n        !transferTaxExempt[to]\n    ) {\n        swapping = true;\n\n        swapBack();\n\n        swapping = false;\n    }\n\n    bool takeFee = !swapping;\n\n    // if any account belongs to _isExcludedFromFee account then remove the fee\n    if (transferTaxExempt[from] || transferTaxExempt[to]) {\n        takeFee = false;\n    }\n\n    uint256 fees = 0;\n    // only take fees on buys/sells, do not take on wallet transfers\n    if (takeFee) {\n        // on sell\n        if (automatedMarketMakerPairs[to] && sellTaxTotal > 0) {\n            fees = amount.mul(sellTaxTotal).div(100);\n            tokensForProject += (fees * sellProjectTax) / sellTaxTotal;\n            tokensForMarketing += (fees * sellMarketingTax) / sellTaxTotal;\n        }\n        // on buy\n        else if (automatedMarketMakerPairs[from] && buyTaxTotal > 0) {\n            fees = amount.mul(buyTaxTotal).div(100);\n            tokensForProject += (fees * buyProjectTax) / buyTaxTotal;\n            tokensForMarketing += (fees * buyMarketingTax) / buyTaxTotal;\n        }\n\n        if (fees > 0) {\n            super._transfer(from, address(this), fees);\n        }\n\n        amount -= fees;\n    }\n\n    super._transfer(from, to, amount);\n}"
"function swapTokensForEth(uint256 tokenAmount) private {\n    // generate the uniswap pair path of token -> weth\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = dexRouter.WETH();\n\n    _approve(address(this), address(dexRouter), tokenAmount);\n\n    // make the swap\n    dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, // accept any amount of ETH\n        path,\n        address(this),\n        block.timestamp\n    );\n}"
"function swapBack() private {\n    uint256 contractBalance = balanceOf(address(this));\n    uint256 totalTokensToSwap = contractBalance;\n    bool success;\n\n    if (contractBalance == 0) {\n        return;\n    }\n\n    if (contractBalance > swapBackValueMax) {\n        contractBalance = swapBackValueMax;\n    }\n\n    uint256 amountToSwapForETH = contractBalance;\n\n    uint256 initialETHBalance = address(this).balance;\n\n    swapTokensForEth(amountToSwapForETH);\n\n    uint256 ethBalance = address(this).balance.sub(initialETHBalance);\n\n    uint256 ethForDev = ethBalance.mul(tokensForProject).div(\n        totalTokensToSwap\n    );\n\n    tokensForMarketing = 0;\n    tokensForProject = 0;\n\n    (success, ) = address(projectWallet).call{value: ethForDev}("""");\n\n    (success, ) = address(marketingWallet).call{\n        value: address(this).balance\n    }("""");\n}"
"function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, ""SafeMath: addition overflow"");\n\n    return c;\n}"
"function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, ""SafeMath: subtraction overflow"");\n}"
"function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n}"
"function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n        return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, ""SafeMath: multiplication overflow"");\n\n    return c;\n}"
"function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, ""SafeMath: division by zero"");\n}"
"function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n}"
"function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, ""SafeMath: modulo by zero"");\n}"
"function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n}"
"function isContract(address account) internal view returns (bool) {\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        codehash := extcodehash(account)\n    }\n    return (codehash != accountHash && codehash != 0x0);\n}"
"function sendValue(address payable recipient, uint256 amount) internal {\n    require(\n        address(this).balance >= amount,\n        ""Address: insufficient balance""\n    );\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}("""");\n    require(\n        success,\n        ""Address: unable to send value, recipient may have reverted""\n    );\n}"
"function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n{\n    return functionCall(target, data, ""Address: low-level call failed"");\n}"
"function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, errorMessage);\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n) internal returns (bytes memory) {\n    return\n        functionCallWithValue(\n            target,\n            data,\n            value,\n            ""Address: low-level call with value failed""\n        );\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(\n        address(this).balance >= value,\n        ""Address: insufficient balance for call""\n    );\n    return _functionCallWithValue(target, data, value, errorMessage);\n}"
"function _functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 weiValue,\n    string memory errorMessage\n) private returns (bytes memory) {\n    require(isContract(target), ""Address: call to non-contract"");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: weiValue}(\n        data\n    );\n    if (success) {\n        return returndata;\n    } else {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}"
"constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n}"
function owner() public view returns (address) {\n    return _owner;\n}
function geUnlockTime() public view returns (uint256) {\n    return _lockTime;\n}
"constructor() {\n    _rOwned[_msgSender()] = _rTotal;\n\n    buyFee.tax = 0;\n    buyFee.liquidity = 47;\n    buyFee.marketing = 48;\n    buyFee.dev = 0;\n    buyFee.donation = 0;\n\n    sellFee.tax = 0;\n    sellFee.liquidity = 47;\n    sellFee.marketing = 48;\n    sellFee.dev = 0;\n    sellFee.donation = 0;\n\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n    );\n    // Create a uniswap pair for this new token\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n        .createPair(address(this), _uniswapV2Router.WETH());\n\n    // set the rest of the contract variables\n    uniswapV2Router = _uniswapV2Router;\n\n    // exclude owner, dev wallet, and this contract from fee\n    _isExcludedFromFee[owner()] = true;\n    _isExcludedFromFee[address(this)] = true;\n    _isExcludedFromFee[_marketingAddress] = true;\n    _isExcludedFromFee[_devwallet] = true;\n    _isExcludedFromFee[_exchangewallet] = true;\n    _isExcludedFromFee[_partnershipswallet] = true;\n\n    _isExcludedFromLimit[_marketingAddress] = true;\n    _isExcludedFromLimit[_devwallet] = true;\n    _isExcludedFromLimit[_exchangewallet] = true;\n    _isExcludedFromLimit[_partnershipswallet] = true;\n    _isExcludedFromLimit[owner()] = true;\n    _isExcludedFromLimit[address(this)] = true;\n\n    emit Transfer(address(0), _msgSender(), _tTotal);\n}"
function name() public view returns (string memory) {\n    return _name;\n}
function symbol() public view returns (string memory) {\n    return _symbol;\n}
function decimals() public view returns (uint8) {\n    return _decimals;\n}
function totalSupply() public view override returns (uint256) {\n    return _tTotal;\n}
function balanceOf(address account) public view override returns (uint256) {\n    if (_isExcluded[account]) return _tOwned[account];\n    return tokenFromReflection(_rOwned[account]);\n}
"function transfer(address recipient, uint256 amount)\n    public\n    override\n    returns (bool)\n{\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n}"
"function allowance(address owner, address spender)\n    public\n    view\n    override\n    returns (uint256)\n{\n    return _allowances[owner][spender];\n}"
"function approve(address spender, uint256 amount)\n    public\n    override\n    returns (bool)\n{\n    _approve(_msgSender(), spender, amount);\n    return true;\n}"
"function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n        sender,\n        _msgSender(),\n        _allowances[sender][_msgSender()].sub(\n            amount,\n            ""ERC20: transfer amount exceeds allowance""\n        )\n    );\n    return true;\n}"
function isExcludedFromReward(address account) public view returns (bool) {\n    return _isExcluded[account];\n}
function totalFees() public view returns (uint256) {\n    return _tFeeTotal;\n}
function donationAddress() public view returns (address) {\n    return _donationAddress;\n}
"function deliver(uint256 tAmount) public {\n    address sender = _msgSender();\n    require(\n        !_isExcluded[sender],\n        ""Excluded addresses cannot call this function""\n    );\n\n    (\n        ,\n        uint256 tFee,\n        uint256 tLiquidity,\n        uint256 tWallet,\n        uint256 tDonation\n    ) = _getTValues(tAmount);\n    (uint256 rAmount, , ) = _getRValues(\n        tAmount,\n        tFee,\n        tLiquidity,\n        tWallet,\n        tDonation,\n        _getRate()\n    );\n\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rTotal = _rTotal.sub(rAmount);\n    _tFeeTotal = _tFeeTotal.add(tAmount);\n}"
"function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\n    public\n    view\n    returns (uint256)\n{\n    require(tAmount <= _tTotal, ""Amount must be less than supply"");\n\n    (\n        ,\n        uint256 tFee,\n        uint256 tLiquidity,\n        uint256 tWallet,\n        uint256 tDonation\n    ) = _getTValues(tAmount);\n    (uint256 rAmount, uint256 rTransferAmount, ) = _getRValues(\n        tAmount,\n        tFee,\n        tLiquidity,\n        tWallet,\n        tDonation,\n        _getRate()\n    );\n\n    if (!deductTransferFee) {\n        return rAmount;\n    } else {\n        return rTransferAmount;\n    }\n}"
"function tokenFromReflection(uint256 rAmount)\n    public\n    view\n    returns (uint256)\n{\n    require(\n        rAmount <= _rTotal,\n        ""Amount must be less than total reflections""\n    );\n    uint256 currentRate = _getRate();\n    return rAmount.div(currentRate);\n}"
function updateMarketingWallet(address payable newAddress) external onlyOwner {\n    _marketingAddress = newAddress;\n}
function updateDevWallet(address payable newAddress) external onlyOwner {\n    _devwallet = newAddress;\n}
function updateExchangeWallet(address newAddress) external onlyOwner {\n    _exchangewallet = newAddress;\n}
function updatePartnershipsWallet(address newAddress) external onlyOwner {\n    _partnershipswallet = newAddress;\n}
"function addBotToBlacklist(address account) external onlyOwner {\n    require(\n        account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D,\n        ""We cannot blacklist UniSwap router""\n    );\n    require(!_isBlackListedBot[account], ""Account is already blacklisted"");\n    _isBlackListedBot[account] = true;\n    _blackListedBots.push(account);\n}"
"function removeBotFromBlacklist(address account) external onlyOwner {\n    require(_isBlackListedBot[account], ""Account is not blacklisted"");\n    for (uint256 i = 0; i < _blackListedBots.length; i++) {\n        if (_blackListedBots[i] == account) {\n            _blackListedBots[i] = _blackListedBots[\n                _blackListedBots.length - 1\n            ];\n            _isBlackListedBot[account] = false;\n            _blackListedBots.pop();\n            break;\n        }\n    }\n}"
"function excludeFromReward(address account) public onlyOwner {\n    require(!_isExcluded[account], ""Account is already excluded"");\n    if (_rOwned[account] > 0) {\n        _tOwned[account] = tokenFromReflection(_rOwned[account]);\n    }\n    _isExcluded[account] = true;\n    _excluded.push(account);\n}"
"function includeInReward(address account) external onlyOwner {\n    require(_isExcluded[account], ""Account is not excluded"");\n    for (uint256 i = 0; i < _excluded.length; i++) {\n        if (_excluded[i] == account) {\n            _excluded[i] = _excluded[_excluded.length - 1];\n            _tOwned[account] = 0;\n            _isExcluded[account] = false;\n            _excluded.pop();\n            break;\n        }\n    }\n}"
function excludeFromFee(address account) public onlyOwner {\n    _isExcludedFromFee[account] = true;\n}
function includeInFee(address account) public onlyOwner {\n    _isExcludedFromFee[account] = false;\n}
function excludeFromLimit(address account) public onlyOwner {\n    _isExcludedFromLimit[account] = true;\n}
function includeInLimit(address account) public onlyOwner {\n    _isExcludedFromLimit[account] = false;\n}
"function setSellFee(\n    uint16 tax,\n    uint16 liquidity,\n    uint16 marketing,\n    uint16 dev,\n    uint16 donation\n) external onlyOwner {\n    sellFee.tax = tax;\n    sellFee.marketing = marketing;\n    sellFee.liquidity = liquidity;\n    sellFee.dev = dev;\n    sellFee.donation = donation;\n}"
"function setBuyFee(\n    uint16 tax,\n    uint16 liquidity,\n    uint16 marketing,\n    uint16 dev,\n    uint16 donation\n) external onlyOwner {\n    buyFee.tax = tax;\n    buyFee.marketing = marketing;\n    buyFee.liquidity = liquidity;\n    buyFee.dev = dev;\n    buyFee.donation = donation;\n}"
"function setBothFees(\n    uint16 buy_tax,\n    uint16 buy_liquidity,\n    uint16 buy_marketing,\n    uint16 buy_dev,\n    uint16 buy_donation,\n    uint16 sell_tax,\n    uint16 sell_liquidity,\n    uint16 sell_marketing,\n    uint16 sell_dev,\n    uint16 sell_donation\n\n) external onlyOwner {\n    buyFee.tax = buy_tax;\n    buyFee.marketing = buy_marketing;\n    buyFee.liquidity = buy_liquidity;\n    buyFee.dev = buy_dev;\n    buyFee.donation = buy_donation;\n\n    sellFee.tax = sell_tax;\n    sellFee.marketing = sell_marketing;\n    sellFee.liquidity = sell_liquidity;\n    sellFee.dev = sell_dev;\n    sellFee.donation = sell_donation;\n}"
function setNumTokensSellToAddToLiquidity(uint256 numTokens) external onlyOwner {\n    numTokensSellToAddToLiquidity = numTokens;\n}
function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner {\n    _maxTxAmount = _tTotal.mul(maxTxPercent).div(10**3);\n}
function _setMaxWalletSizePercent(uint256 maxWalletSize)\n    external\n    onlyOwner\n{\n    _maxWalletSize = _tTotal.mul(maxWalletSize).div(10**3);\n}
function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n    swapAndLiquifyEnabled = _enabled;\n    emit SwapAndLiquifyEnabledUpdated(_enabled);\n}
receive() external payable {}
"function _reflectFee(uint256 rFee, uint256 tFee) private {\n    _rTotal = _rTotal.sub(rFee);\n    _tFeeTotal = _tFeeTotal.add(tFee);\n}"
"function _getTValues(uint256 tAmount)\n    private\n    view\n    returns (\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256\n    )\n{\n    uint256 tFee = calculateTaxFee(tAmount);\n    uint256 tLiquidity = calculateLiquidityFee(tAmount);\n    uint256 tWallet = calculateMarketingFee(tAmount) +\n        calculateDevFee(tAmount);\n    uint256 tDonation = calculateDonationFee(tAmount);\n    uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity);\n    tTransferAmount = tTransferAmount.sub(tWallet);\n    tTransferAmount = tTransferAmount.sub(tDonation);\n\n    return (tTransferAmount, tFee, tLiquidity, tWallet, tDonation);\n}"
"function _getRValues(\n    uint256 tAmount,\n    uint256 tFee,\n    uint256 tLiquidity,\n    uint256 tWallet,\n    uint256 tDonation,\n    uint256 currentRate\n)\n    private\n    pure\n    returns (\n        uint256,\n        uint256,\n        uint256\n    )\n{\n    uint256 rAmount = tAmount.mul(currentRate);\n    uint256 rFee = tFee.mul(currentRate);\n    uint256 rLiquidity = tLiquidity.mul(currentRate);\n    uint256 rWallet = tWallet.mul(currentRate);\n    uint256 rDonation = tDonation.mul(currentRate);\n    uint256 rTransferAmount = rAmount\n        .sub(rFee)\n        .sub(rLiquidity)\n        .sub(rWallet)\n        .sub(rDonation);\n    return (rAmount, rTransferAmount, rFee);\n}"
"function _getRate() private view returns (uint256) {\n    (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n    return rSupply.div(tSupply);\n}"
"function _getCurrentSupply() private view returns (uint256, uint256) {\n    uint256 rSupply = _rTotal;\n    uint256 tSupply = _tTotal;\n    for (uint256 i = 0; i < _excluded.length; i++) {\n        if (\n            _rOwned[_excluded[i]] > rSupply ||\n            _tOwned[_excluded[i]] > tSupply\n        ) return (_rTotal, _tTotal);\n        rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n        tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n    }\n    if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n    return (rSupply, tSupply);\n}"
function _takeLiquidity(uint256 tLiquidity) private {\n    uint256 currentRate = _getRate();\n    uint256 rLiquidity = tLiquidity.mul(currentRate);\n    _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\n    if (_isExcluded[address(this)])\n        _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\n}
function _takeWalletFee(uint256 tWallet) private {\n    uint256 currentRate = _getRate();\n    uint256 rWallet = tWallet.mul(currentRate);\n    _rOwned[address(this)] = _rOwned[address(this)].add(rWallet);\n    if (_isExcluded[address(this)])\n        _tOwned[address(this)] = _tOwned[address(this)].add(tWallet);\n}
function _takeDonationFee(uint256 tDonation) private {\n    uint256 currentRate = _getRate();\n    uint256 rDonation = tDonation.mul(currentRate);\n    _rOwned[_donationAddress] = _rOwned[_donationAddress].add(rDonation);\n    if (_isExcluded[_donationAddress])\n        _tOwned[_donationAddress] = _tOwned[_donationAddress].add(\n            tDonation\n        );\n}
function calculateTaxFee(uint256 _amount) private view returns (uint256) {\n    return _amount.mul(_taxFee).div(10**2);\n}
function calculateLiquidityFee(uint256 _amount)\n    private\n    view\n    returns (uint256)\n{\n    return _amount.mul(_liquidityFee).div(10**2);\n}
function calculateMarketingFee(uint256 _amount)\n    private\n    view\n    returns (uint256)\n{\n    return _amount.mul(_marketingFee).div(10**2);\n}
function calculateDonationFee(uint256 _amount)\n    private\n    view\n    returns (uint256)\n{\n    return _amount.mul(_donationFee).div(10**2);\n}
function calculateDevFee(uint256 _amount) private view returns (uint256) {\n    return _amount.mul(_devFee).div(10**2);\n}
function removeAllFee() private {\n    _taxFee = 0;\n    _liquidityFee = 0;\n    _marketingFee = 0;\n    _donationFee = 0;\n    _devFee = 0;\n}
function setBuy() private {\n    _taxFee = buyFee.tax;\n    _liquidityFee = buyFee.liquidity;\n    _marketingFee = buyFee.marketing;\n    _donationFee = buyFee.donation;\n    _devFee = buyFee.dev;\n}
function setSell() private {\n    _taxFee = sellFee.tax;\n    _liquidityFee = sellFee.liquidity;\n    _marketingFee = sellFee.marketing;\n    _donationFee = sellFee.donation;\n    _devFee = sellFee.dev;\n}
function isExcludedFromFee(address account) public view returns (bool) {\n    return _isExcludedFromFee[account];\n}
function isExcludedFromLimit(address account) public view returns (bool) {\n    return _isExcludedFromLimit[account];\n}
"function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n) private {\n    require(owner != address(0), ""ERC20: approve from the zero address"");\n    require(spender != address(0), ""ERC20: approve to the zero address"");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n}"
"function _transfer(\n    address from,\n    address to,\n    uint256 amount\n) private {\n    require(from != address(0), ""ERC20: transfer from the zero address"");\n    require(to != address(0), ""ERC20: transfer to the zero address"");\n    require(amount > 0, ""Transfer amount must be greater than zero"");\n    require(!_isBlackListedBot[from], ""You are blacklisted"");\n    require(!_isBlackListedBot[msg.sender], ""blacklisted"");\n    require(!_isBlackListedBot[tx.origin], ""blacklisted"");\n\n    // is the token balance of this contract address over the min number of\n    // tokens that we need to initiate a swap + liquidity lock?\n    // also, don't get caught in a circular liquidity event.\n    // also, don't swap & liquify if sender is uniswap pair.\n    uint256 contractTokenBalance = balanceOf(address(this));\n\n    if (contractTokenBalance >= _maxTxAmount) {\n        contractTokenBalance = _maxTxAmount;\n    }\n\n    bool overMinTokenBalance = contractTokenBalance >=\n        numTokensSellToAddToLiquidity;\n    if (\n        overMinTokenBalance &&\n        !inSwapAndLiquify &&\n        from != uniswapV2Pair &&\n        swapAndLiquifyEnabled\n    ) {\n        contractTokenBalance = numTokensSellToAddToLiquidity;\n        //add liquidity\n        swapAndLiquify(contractTokenBalance);\n    }\n\n    //indicates if fee should be deducted from transfer\n    bool takeFee = true;\n\n    //if any account belongs to _isExcludedFromFee account then remove the fee\n    if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\n        takeFee = false;\n    }\n    if (takeFee) {\n        if (!_isExcludedFromLimit[from] && !_isExcludedFromLimit[to]) {\n            require(\n                amount <= _maxTxAmount,\n                ""Transfer amount exceeds the maxTxAmount.""\n            );\n            if (to != uniswapV2Pair) {\n                require(\n                    amount + balanceOf(to) <= _maxWalletSize,\n                    ""Recipient exceeds max wallet size.""\n                );\n            }\n        }\n    }\n\n    //transfer amount, it will take tax, burn, liquidity fee\n    _tokenTransfer(from, to, amount, takeFee);\n}"
"function swapAndLiquify(uint256 tokens) private lockTheSwap {\n    // Split the contract balance into halves\n    uint256 denominator = (buyFee.liquidity +\n        sellFee.liquidity +\n        buyFee.marketing +\n        sellFee.marketing +\n        buyFee.dev +\n        sellFee.dev) * 2;\n    uint256 tokensToAddLiquidityWith = (tokens *\n        (buyFee.liquidity + sellFee.liquidity)) / denominator;\n    uint256 toSwap = tokens - tokensToAddLiquidityWith;\n\n    uint256 initialBalance = address(this).balance;\n\n    swapTokensForEth(toSwap);\n\n    uint256 deltaBalance = address(this).balance - initialBalance;\n    uint256 unitBalance = deltaBalance /\n        (denominator - (buyFee.liquidity + sellFee.liquidity));\n    uint256 bnbToAddLiquidityWith = unitBalance *\n        (buyFee.liquidity + sellFee.liquidity);\n\n    if (bnbToAddLiquidityWith > 0) {\n        // Add liquidity to pancake\n        addLiquidity(tokensToAddLiquidityWith, bnbToAddLiquidityWith);\n    }\n\n    // Send ETH to marketing\n    uint256 marketingAmt = unitBalance *\n        2 *\n        (buyFee.marketing + sellFee.marketing);\n    uint256 devAmt = unitBalance * 2 * (buyFee.dev + sellFee.dev) >\n        address(this).balance\n        ? address(this).balance\n        : unitBalance * 2 * (buyFee.dev + sellFee.dev);\n\n    if (marketingAmt > 0) {\n        payable(_marketingAddress).transfer(marketingAmt);\n    }\n\n    if (devAmt > 0) {\n        _devwallet.transfer(devAmt);\n    }\n}"
"function swapTokensForEth(uint256 tokenAmount) private {\n    // generate the uniswap pair path of token -> weth\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    // make the swap\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, // accept any amount of ETH\n        path,\n        address(this),\n        block.timestamp\n    );\n}"
"function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n    // approve token transfer to cover all possible scenarios\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    // add the liquidity\n    uniswapV2Router.addLiquidityETH{value: ethAmount}(\n        address(this),\n        tokenAmount,\n        0, // slippage is unavoidable\n        0, // slippage is unavoidable\n        address(this),\n        block.timestamp\n    );\n}"
"function _tokenTransfer(\n    address sender,\n    address recipient,\n    uint256 amount,\n    bool takeFee\n) private {\n    if (takeFee) {\n        removeAllFee();\n        if (sender == uniswapV2Pair) {\n            setBuy();\n        }\n        if (recipient == uniswapV2Pair) {\n            setSell();\n        }\n    }\n\n    if (_isExcluded[sender] && !_isExcluded[recipient]) {\n        _transferFromExcluded(sender, recipient, amount);\n    } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n        _transferToExcluded(sender, recipient, amount);\n    } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n        _transferStandard(sender, recipient, amount);\n    } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n        _transferBothExcluded(sender, recipient, amount);\n    } else {\n        _transferStandard(sender, recipient, amount);\n    }\n    removeAllFee();\n}"
"function _transferStandard(\n    address sender,\n    address recipient,\n    uint256 tAmount\n) private {\n    (\n        uint256 tTransferAmount,\n        uint256 tFee,\n        uint256 tLiquidity,\n        uint256 tWallet,\n        uint256 tDonation\n    ) = _getTValues(tAmount);\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\n        tAmount,\n        tFee,\n        tLiquidity,\n        tWallet,\n        tDonation,\n        _getRate()\n    );\n\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n    _takeLiquidity(tLiquidity);\n    _takeWalletFee(tWallet);\n    _takeDonationFee(tDonation);\n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}"
"function _transferToExcluded(\n    address sender,\n    address recipient,\n    uint256 tAmount\n) private {\n    (\n        uint256 tTransferAmount,\n        uint256 tFee,\n        uint256 tLiquidity,\n        uint256 tWallet,\n        uint256 tDonation\n    ) = _getTValues(tAmount);\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\n        tAmount,\n        tFee,\n        tLiquidity,\n        tWallet,\n        tDonation,\n        _getRate()\n    );\n\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n    _takeLiquidity(tLiquidity);\n    _takeWalletFee(tWallet);\n    _takeDonationFee(tDonation);\n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}"
"function _transferFromExcluded(\n    address sender,\n    address recipient,\n    uint256 tAmount\n) private {\n    (\n        uint256 tTransferAmount,\n        uint256 tFee,\n        uint256 tLiquidity,\n        uint256 tWallet,\n        uint256 tDonation\n    ) = _getTValues(tAmount);\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\n        tAmount,\n        tFee,\n        tLiquidity,\n        tWallet,\n        tDonation,\n        _getRate()\n    );\n\n    _tOwned[sender] = _tOwned[sender].sub(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n    _takeLiquidity(tLiquidity);\n    _takeWalletFee(tWallet);\n    _takeDonationFee(tDonation);\n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}"
"function _transferBothExcluded(\n    address sender,\n    address recipient,\n    uint256 tAmount\n) private {\n    (\n        uint256 tTransferAmount,\n        uint256 tFee,\n        uint256 tLiquidity,\n        uint256 tWallet,\n        uint256 tDonation\n    ) = _getTValues(tAmount);\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\n        tAmount,\n        tFee,\n        tLiquidity,\n        tWallet,\n        tDonation,\n        _getRate()\n    );\n\n    _tOwned[sender] = _tOwned[sender].sub(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n    _takeLiquidity(tLiquidity);\n    _takeWalletFee(tWallet);\n    _takeDonationFee(tDonation);\n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}"
"   constructor(\n       IERC20Permit _token,\n       uint256 _endingTimestamp,\n       address _recipient,\n       uint256 _tokenToEthRate,\n       bytes32 _termsHash,\n       Blocklist _blocklist\n   ) {\n       token = _token;\n       endingTimestamp = _endingTimestamp;\n       recipient = _recipient;\n       tokenAmountBase = 10 ** token.decimals();\n       tokenToEthRate = _tokenToEthRate;\n       termsHash = _termsHash;\n       blocklist = _blocklist;\n"
"   function permitRedeem(\n       bytes32 _termsHash,\n       uint256 amount,\n       uint256 deadline,\n       uint8 v,\n       bytes32 r,\n       bytes32 s\n   ) external {\n       token.permit(msg.sender, address(this), amount, deadline, v, r, s);\n       redeem(_termsHash, amount);\n"
"   function redeem(bytes32 _termsHash, uint256 tokenAmount) public {\n       if (blocklist.isBlocklisted(msg.sender)) {\n           revert AddressBlocklisted();\n       }\n       if (termsHash != _termsHash) {\n           revert TermsNotCorrect();\n       }\n       if (block.timestamp > endingTimestamp) {\n           revert RedemptionPeriodFinished();\n       }\n\n       token.transferFrom(msg.sender, address(this), tokenAmount);\n       uint256 ethToSend = (tokenAmount * tokenToEthRate) / tokenAmountBase;\n       (bool result, ) = msg.sender.call{value: ethToSend}("""");\n       if (!result) {\n           revert FailedToSendEth();\n       }\n\n       emit EthClaimed(msg.sender, tokenAmount, ethToSend);\n"
"   function claimRemainings() external {\n       if (block.timestamp <= endingTimestamp) {\n           revert RedemptionPeriodNotFinished();\n       }\n\n       // Sending the token to the burning address\n       token.transfer(DEAD_ADDRESS, token.balanceOf(address(this)));\n       recipient.call{value: address(this).balance}("""");\n"
"   receive() external payable {\n       emit EthReceived(msg.sender, msg.value);\n"
"constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}"
function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n}
function increment(Counter storage counter) internal {\n    unchecked {\n        counter._value += 1;\n    }\n}
"function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, ""Counter: decrement overflow"");\n    unchecked {\n        counter._value = value - 1;\n    }\n}"
function reset(Counter storage counter) internal {\n    counter._value = 0;\n}
"constructor(string memory name) EIP712(name, ""1"") {}"
function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n    return _domainSeparatorV4();\n}
"function max(int256 a, int256 b) internal pure returns (int256) {\n    return a > b ? a : b;\n}"
"function min(int256 a, int256 b) internal pure returns (int256) {\n    return a < b ? a : b;\n}"
"function average(int256 a, int256 b) internal pure returns (int256) {\n    // Formula from the book ""Hacker's Delight""\n    int256 x = (a & b) + ((a ^ b) >> 1);\n    return x + (int256(uint256(x) >> 255) & (a ^ b));\n}"
function abs(int256 n) internal pure returns (uint256) {\n    unchecked {\n        // must be unchecked in order to support `n = type(int256).min`\n        return uint256(n >= 0 ? n : -n);\n    }\n}
"function _throwError(RecoverError error) private pure {\n    if (error == RecoverError.NoError) {\n        return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n        revert(""ECDSA: invalid signature"");\n    } else if (error == RecoverError.InvalidSignatureLength) {\n        revert(""ECDSA: invalid signature length"");\n    } else if (error == RecoverError.InvalidSignatureS) {\n        revert(""ECDSA: invalid signature 's' value"");\n    }\n}"
"function tryRecover(\n    bytes32 hash,\n    bytes memory signature\n) internal pure returns (address, RecoverError) {\n    if (signature.length == 65) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        return tryRecover(hash, v, r, s);\n    } else {\n        return (address(0), RecoverError.InvalidSignatureLength);\n    }\n}"
"function recover(\n    bytes32 hash,\n    bytes memory signature\n) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\n    _throwError(error);\n    return recovered;\n}"
"function tryRecover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n) internal pure returns (address, RecoverError) {\n    bytes32 s = vs &\n        bytes32(\n            0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\n    return tryRecover(hash, v, r, s);\n}"
"function recover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n    _throwError(error);\n    return recovered;\n}"
"function tryRecover(\n       bytes32 hash,\n       uint8 v,\n       bytes32 r,\n       bytes32 s\n   ) internal pure returns (address, RecoverError) {\n       // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n       // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n       // the valid range for s in (301): 0 < s < secp256k1n Ã· 2 + 1, and for v in (302): v âˆˆ {27, 28}. Most\n       // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n       //\n       // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n       // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n       // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n       // these malleable signatures as well.\n       if (\n           uint256(s) >\n           0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n       ) {\n           return (address(0), RecoverError.InvalidSignatureS);\n       }\n\n       // If the signature is valid (and not malleable), return the signer address\n       address signer = ecrecover(hash, v, r, s);\n       if (signer == address(0)) {\n           return (address(0), RecoverError.InvalidSignature);\n       }\n\n       return (signer, RecoverError.NoError);\n   }\n\n"
"function recover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n    _throwError(error);\n    return recovered;\n}"
"function toEthSignedMessageHash(\n    bytes32 hash\n) internal pure returns (bytes32 message) {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    /// @solidity memory-safe-assembly\n    assembly {\n        mstore(0x00, ""\x19Ethereum Signed Message:\n32"")\n        mstore(0x1c, hash)\n        message := keccak256(0x00, 0x3c)\n    }\n}"
"function toEthSignedMessageHash(\n    bytes memory s\n) internal pure returns (bytes32) {\n    return\n        keccak256(\n            abi.encodePacked(\n                ""\x19Ethereum Signed Message:\n"",\n                Strings.toString(s.length),\n                s\n            )\n        );\n}"
"function toTypedDataHash(\n    bytes32 domainSeparator,\n    bytes32 structHash\n) internal pure returns (bytes32 data) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        let ptr := mload(0x40)\n        mstore(ptr, ""\x19\x01"")\n        mstore(add(ptr, 0x02), domainSeparator)\n        mstore(add(ptr, 0x22), structHash)\n        data := keccak256(ptr, 0x42)\n    }\n}"
"function toDataWithIntendedValidatorHash(\n    address validator,\n    bytes memory data\n) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(""\x19\x00"", validator, data));\n}"
function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        r.slot := slot\n    }\n}
function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        r.slot := slot\n    }\n}
function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        r.slot := slot\n    }\n}
function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        r.slot := slot\n    }\n}
function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        r.slot := slot\n    }\n}
function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        r.slot := store.slot\n    }\n}
function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        r.slot := slot\n    }\n}
function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        r.slot := store.slot\n    }\n}
constructor(address[] memory blockedAddresses) {\n  for (uint i = 0; i < blockedAddresses.length; ) {\n    blocklist[blockedAddresses[i]] = true;\n    unchecked {\n      i += 1;\n    }\n  }\n}
function isBlocklisted(address _address) public view returns (bool) {\n  return blocklist[_address];\n}
function toShortString(string memory str) internal pure returns (ShortString) {\n    bytes memory bstr = bytes(str);\n    if (bstr.length > 31) {\n        revert StringTooLong(str);\n    }\n    return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n}
"function toString(ShortString sstr) internal pure returns (string memory) {\n    uint256 len = byteLength(sstr);\n    // using `new string(len)` would work locally but is not memory safe.\n    string memory str = new string(32);\n    /// @solidity memory-safe-assembly\n    assembly {\n        mstore(str, len)\n        mstore(add(str, 0x20), sstr)\n    }\n    return str;\n}"
function byteLength(ShortString sstr) internal pure returns (uint256) {\n    uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n    if (result > 31) {\n        revert InvalidShortString();\n    }\n    return result;\n}
"function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n    if (bytes(value).length < 32) {\n        return toShortString(value);\n    } else {\n        StorageSlot.getStringSlot(store).value = value;\n        return ShortString.wrap(_FALLBACK_SENTINEL);\n    }\n}"
"function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n    if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n        return toString(value);\n    } else {\n        return store;\n    }\n}"
"function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n    if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n        return byteLength(value);\n    } else {\n        return bytes(store).length;\n    }\n}"
"function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n}"
"function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n}"
"function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n}"
"function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n}"
"function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n    unchecked {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n            // The surrounding unchecked block does not change this fact.\n            // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n            return prod0 / denominator;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        require(denominator > prod1, ""Math: mulDiv overflow"");\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 twos = denominator & (~denominator + 1);\n        assembly {\n            // Divide denominator by twos.\n            denominator := div(denominator, twos)\n\n            // Divide [prod1 prod0] by twos.\n            prod0 := div(prod0, twos)\n\n            // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n        return result;\n    }\n}"
"function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n        result += 1;\n    }\n    return result;\n}"
"function sqrt(uint256 a) internal pure returns (uint256) {\n      if (a == 0) {\n          return 0;\n      }\n\n      // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n      //\n      // We know that the ""msb"" (most significant bit) of our target number `a` is a power of 2 such that we have\n      // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n      //\n      // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n      // â†’ `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n      // â†’ `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n      //\n      // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n      uint256 result = 1 << (log2(a) >> 1);\n\n      // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n      // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n      // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n      // into the expected uint128 result.\n      unchecked {\n          result = (result + a / result) >> 1;\n          result = (result + a / result) >> 1;\n          result = (result + a / result) >> 1;\n          result = (result + a / result) >> 1;\n          result = (result + a / result) >> 1;\n          result = (result + a / result) >> 1;\n          result = (result + a / result) >> 1;\n          return min(result, a / result);\n      }\n  }\n\n"
"function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n        uint256 result = sqrt(a);\n        return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n    }\n}"
function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n        if (value >> 128 > 0) {\n            value >>= 128;\n            result += 128;\n        }\n        if (value >> 64 > 0) {\n            value >>= 64;\n            result += 64;\n        }\n        if (value >> 32 > 0) {\n            value >>= 32;\n            result += 32;\n        }\n        if (value >> 16 > 0) {\n            value >>= 16;\n            result += 16;\n        }\n        if (value >> 8 > 0) {\n            value >>= 8;\n            result += 8;\n        }\n        if (value >> 4 > 0) {\n            value >>= 4;\n            result += 4;\n        }\n        if (value >> 2 > 0) {\n            value >>= 2;\n            result += 2;\n        }\n        if (value >> 1 > 0) {\n            result += 1;\n        }\n    }\n    return result;\n}
"function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n        uint256 result = log2(value);\n        return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n    }\n}"
function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n        if (value >= 10 ** 64) {\n            value /= 10 ** 64;\n            result += 64;\n        }\n        if (value >= 10 ** 32) {\n            value /= 10 ** 32;\n            result += 32;\n        }\n        if (value >= 10 ** 16) {\n            value /= 10 ** 16;\n            result += 16;\n        }\n        if (value >= 10 ** 8) {\n            value /= 10 ** 8;\n            result += 8;\n        }\n        if (value >= 10 ** 4) {\n            value /= 10 ** 4;\n            result += 4;\n        }\n        if (value >= 10 ** 2) {\n            value /= 10 ** 2;\n            result += 2;\n        }\n        if (value >= 10 ** 1) {\n            result += 1;\n        }\n    }\n    return result;\n}
"function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n        uint256 result = log10(value);\n        return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n    }\n}"
function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n        if (value >> 128 > 0) {\n            value >>= 128;\n            result += 16;\n        }\n        if (value >> 64 > 0) {\n            value >>= 64;\n            result += 8;\n        }\n        if (value >> 32 > 0) {\n            value >>= 32;\n            result += 4;\n        }\n        if (value >> 16 > 0) {\n            value >>= 16;\n            result += 2;\n        }\n        if (value >> 8 > 0) {\n            result += 1;\n        }\n    }\n    return result;\n}
"function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n        uint256 result = log256(value);\n        return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n    }\n}"
"function toString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n        uint256 length = Math.log10(value) + 1;\n        string memory buffer = new string(length);\n        uint256 ptr;\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr := add(buffer, add(32, length))\n        }\n        while (true) {\n            ptr--;\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n            }\n            value /= 10;\n            if (value == 0) break;\n        }\n        return buffer;\n    }\n}"
"function toString(int256 value) internal pure returns (string memory) {\n    return string(abi.encodePacked(value < 0 ? ""-"" : """", toString(SignedMath.abs(value))));\n}"
"function toHexString(uint256 value) internal pure returns (string memory) {\n    unchecked {\n        return toHexString(value, Math.log256(value) + 1);\n    }\n}"
"function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = ""0"";\n    buffer[1] = ""x"";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n        buffer[i] = _SYMBOLS[value & 0xf];\n        value >>= 4;\n    }\n    require(value == 0, ""Strings: hex length insufficient"");\n    return string(buffer);\n}"
"function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n}"
"function equal(string memory a, string memory b) internal pure returns (bool) {\n    return keccak256(bytes(a)) == keccak256(bytes(b));\n}"
"constructor(string memory name, string memory version) {\n    _name = name.toShortStringWithFallback(_nameFallback);\n    _version = version.toShortStringWithFallback(_versionFallback);\n    _hashedName = keccak256(bytes(name));\n    _hashedVersion = keccak256(bytes(version));\n\n    _cachedChainId = block.chainid;\n    _cachedDomainSeparator = _buildDomainSeparator();\n    _cachedThis = address(this);\n}"
function _domainSeparatorV4() internal view returns (bytes32) {\n    if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n        return _cachedDomainSeparator;\n    } else {\n        return _buildDomainSeparator();\n    }\n}
"function _buildDomainSeparator() private view returns (bytes32) {\n    return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n}"
"function verify(\n    bytes32[] memory proof,\n    bytes32 root,\n    bytes32 leaf\n) internal pure returns (bool) {\n    return processProof(proof, leaf) == root;\n}"
"function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n        bytes32 proofElement = proof[i];\n        if (computedHash <= proofElement) {\n            // Hash(current computed hash + current element of the proof)\n            computedHash = _efficientHash(computedHash, proofElement);\n        } else {\n            // Hash(current element of the proof + current computed hash)\n            computedHash = _efficientHash(proofElement, computedHash);\n        }\n    }\n    return computedHash;\n}"
"function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n    assembly {\n        mstore(0x00, a)\n        mstore(0x20, b)\n        value := keccak256(0x00, 0x40)\n    }\n}"
constructor() {\n    _transferOwnership(_msgSender());\n}
constructor() {\n    _paused = false;\n}
"function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n}"
"function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, ""Address: insufficient balance"");\n\n    (bool success, ) = recipient.call{value: amount}("""");\n    require(success, ""Address: unable to send value, recipient may have reverted"");\n}"
"function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, ""Address: low-level call failed"");\n}"
"function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");\n}"
"function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(address(this).balance >= value, ""Address: insufficient balance for call"");\n    require(isContract(target), ""Address: call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, ""Address: low-level static call failed"");\n}"
"function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal view returns (bytes memory) {\n    require(isContract(target), ""Address: static call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");\n}"
"function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n) internal returns (bytes memory) {\n    require(isContract(target), ""Address: delegate call to non-contract"");\n\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n}"
"function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n) internal pure returns (bytes memory) {\n    if (success) {\n        return returndata;\n    } else {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}"
constructor(string memory uri_) {\n    _setURI(uri_);\n}
"function _doSafeTransferAcceptanceCheck(\n    address operator,\n    address from,\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n) private {\n    if (to.isContract()) {\n        try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n            if (response != IERC1155Receiver.onERC1155Received.selector) {\n                revert(""ERC1155: ERC1155Receiver rejected tokens"");\n            }\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch {\n            revert(""ERC1155: transfer to non ERC1155Receiver implementer"");\n        }\n    }\n}"
"function _doSafeBatchTransferAcceptanceCheck(\n    address operator,\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n) private {\n    if (to.isContract()) {\n        try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n            bytes4 response\n        ) {\n            if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                revert(""ERC1155: ERC1155Receiver rejected tokens"");\n            }\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch {\n            revert(""ERC1155: transfer to non ERC1155Receiver implementer"");\n        }\n    }\n}"
function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n    uint256[] memory array = new uint256[](1);\n    array[0] = element;\n\n    return array;\n}
"constructor(\n    address platformAddress,\n    address platformMintingAddress,\n    bytes32 pixelMerkleRoot,\n    bytes32 pillMerkleRoot,\n    uint256 startTimestamp,\n    string memory newURI\n) ERC1155(newURI) {\n    defaultSaleStartTime = startTimestamp;\n    defaultPlatformAddress = payable(platformAddress);\n    defaultPlatformMintingAddress = platformMintingAddress;\n    merkleRootOfPixelMintWhitelistAddresses = pixelMerkleRoot;\n    merkleRootOfPillMintWhitelistAddresses = pillMerkleRoot;\n\n    _mintGenesisNFT();\n\n    emit NewURI(newURI, msg.sender);\n    emit UpdatedMerkleRootOfPixelMint(pixelMerkleRoot, msg.sender);\n    emit UpdatedMerkleRootOfPillMint(pillMerkleRoot, msg.sender);\n    emit UpdatedPlatformWalletAddress(platformAddress, msg.sender);\n    emit UpdatedPlatformMintingAddress(platformMintingAddress, msg.sender);\n    emit UpdatedSaleStartTime(startTimestamp, msg.sender);\n}"
"function _mintGenesisNFT() internal {\n    _tokenIds++;\n\n    emit GenesisNFTMinted(_tokenIds, msg.sender);\n\n    _mint(msg.sender, _tokenIds, 1, """");\n}"
function getCurrentMintingCount() external view returns (uint256) {\n    return _tokenIds;\n}
function getCurrentNFTMintingPrice() public view returns (uint256) {\n    if (block.timestamp < defaultSaleStartTime) return DEFAULT_NFT_PRICE;\n\n    uint256 calculateTimeDifference = block.timestamp -\n        defaultSaleStartTime;\n\n    uint256 calculateIntervals = calculateTimeDifference /\n        DEFAULT_TIME_INTERVAL;\n\n    if (calculateIntervals >= MAX_DECREASE_ITERATIONS) {\n        uint256 calculatePrice = (DEFAULT_NFT_PRICE -\n            (DEFAULT_DECREASE_NFT_PRICE_AFTER_TIME_INTERVAL *\n                MAX_DECREASE_ITERATIONS));\n\n        return calculatePrice;\n    } else {\n        uint256 calculatePrice = (DEFAULT_NFT_PRICE -\n            (DEFAULT_DECREASE_NFT_PRICE_AFTER_TIME_INTERVAL *\n                calculateIntervals));\n\n        return calculatePrice;\n    }\n}
function checkSaleType() external view returns (SaleType activeSale) {\n    if (block.timestamp < defaultSaleStartTime) {\n        return SaleType.NotStarted;\n    } else if (\n        (block.timestamp >= defaultSaleStartTime) &&\n        (block.timestamp <\n            defaultSaleStartTime + DEFAULT_INITIAL_PUBLIC_SALE)\n    ) {\n        return SaleType.FirstPublicMint;\n    } else if (\n        (block.timestamp >=\n            defaultSaleStartTime + DEFAULT_INITIAL_PUBLIC_SALE) &&\n        (block.timestamp < defaultSaleStartTime + DEFAULT_PIXELMINT_SALE)\n    ) {\n        return SaleType.PixelMint;\n    } else if (\n        (block.timestamp >=\n            defaultSaleStartTime + DEFAULT_PIXELMINT_SALE) &&\n        (block.timestamp < defaultSaleStartTime + DEFAULT_PILLMINT_SALE)\n    ) {\n        return SaleType.PillMint;\n    } else if (\n        (block.timestamp >= defaultSaleStartTime + DEFAULT_PILLMINT_SALE) &&\n        (block.timestamp < defaultSaleStartTime + DEFAULT_TEAMMINT_SALE)\n    ) {\n        return SaleType.TeamMint;\n    } else if (\n        (block.timestamp >= defaultSaleStartTime + DEFAULT_TEAMMINT_SALE)\n    ) {\n        return SaleType.LastPublicMint;\n    }\n}
"function updateTokenURI(string memory newuri)\n    external\n    onlyOwner\n    returns (bool)\n{\n    _setURI(newuri);\n    emit NewURI(newuri, msg.sender);\n    return true;\n}"
"function updatePixelMintMerkleRoot(bytes32 hash)\n    external\n    onlyOwner\n    returns (bool)\n{\n    merkleRootOfPixelMintWhitelistAddresses = hash;\n    emit UpdatedMerkleRootOfPixelMint(hash, msg.sender);\n\n    return true;\n}"
"function updatePillMintMerkleRoot(bytes32 hash)\n    external\n    onlyOwner\n    returns (bool)\n{\n    merkleRootOfPillMintWhitelistAddresses = hash;\n    emit UpdatedMerkleRootOfPillMint(hash, msg.sender);\n\n    return true;\n}"
"function updatePlatformWalletAddress(address newAddress)\n    external\n    onlyOwner\n    returns (bool)\n{\n    defaultPlatformAddress = payable(newAddress);\n    emit UpdatedPlatformWalletAddress(newAddress, msg.sender);\n\n    return true;\n}"
function pauseContract() external onlyOwner returns (bool) {\n    _pause();\n    return true;\n}
function unpauseContract() external onlyOwner returns (bool) {\n    _unpause();\n    return true;\n}
"function firstPublicMintingSale() external payable returns (bool) {\n    if (\n        (block.timestamp >= defaultSaleStartTime) &&\n        (block.timestamp <\n            defaultSaleStartTime + DEFAULT_INITIAL_PUBLIC_SALE)\n    ) {\n        _tokenIds++;\n\n        if (_tokenIds > DEFAULT_MAX_FIRST_PUBLIC_SUPPLY)\n            revert MaximumPublicMintSupplyReached();\n\n        if (firstPublicSale[msg.sender] >= LIMIT_IN_PUBLIC_SALE_PER_WALLET)\n            revert MaximumMintLimitReachedByUser();\n\n        uint256 getPriceOFNFT = getCurrentNFTMintingPrice();\n\n        if (getPriceOFNFT != msg.value)\n            revert InvalidBuyNFTPrice(getPriceOFNFT, msg.value);\n\n        dutchAuctionLastPrice = getPriceOFNFT;\n\n        firstPublicSale[msg.sender] = firstPublicSale[msg.sender] + 1;\n\n        emit NewNFTMintedOnFirstPublicSale(\n            _tokenIds,\n            msg.sender,\n            msg.value\n        );\n\n        _mint(msg.sender, _tokenIds, 1, """");\n\n        return true;\n    } else {\n        revert UnAuthorizedRequest();\n    }\n}"
"function pixelMintingSale(bytes32[] calldata _merkleProof)\n    external\n    payable\n    returns (bool)\n{\n    if (\n        (block.timestamp >=\n            defaultSaleStartTime + DEFAULT_INITIAL_PUBLIC_SALE) &&\n        (block.timestamp < defaultSaleStartTime + DEFAULT_PIXELMINT_SALE)\n    ) {\n        _tokenIds++;\n\n        if (dutchAuctionLastPrice != msg.value)\n            revert InvalidBuyNFTPrice(dutchAuctionLastPrice, msg.value);\n\n        if (pixelMintWhitelistedAddresses[msg.sender] != 0)\n            revert WhitelistedAddressAlreadyClaimedNFT();\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n        if (\n            !MerkleProof.verify(\n                _merkleProof,\n                merkleRootOfPixelMintWhitelistAddresses,\n                leaf\n            )\n        ) revert InvalidMerkleProof();\n\n        pixelMintWhitelistedAddresses[msg.sender] = 1;\n\n        emit NewNFTMintedOnPixelSale(_tokenIds, msg.sender, msg.value);\n\n        _mint(msg.sender, _tokenIds, 1, """");\n\n        return true;\n    } else {\n        revert UnAuthorizedRequest();\n    }\n}"
"function pillMintingSale(bytes32[] calldata _merkleProof)\n    external\n    payable\n    returns (bool)\n{\n    if (\n        (block.timestamp >=\n            defaultSaleStartTime + DEFAULT_PIXELMINT_SALE) &&\n        (block.timestamp < defaultSaleStartTime + DEFAULT_PILLMINT_SALE)\n    ) {\n        _tokenIds++;\n\n        if (pillMintWhitelistedAddresses[msg.sender] != 0)\n            revert WhitelistedAddressAlreadyClaimedNFT();\n\n        if ((dutchAuctionLastPrice / 2) != msg.value)\n            revert InvalidBuyNFTPrice(\n                (dutchAuctionLastPrice / 2),\n                msg.value\n            );\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n        if (\n            !MerkleProof.verify(\n                _merkleProof,\n                merkleRootOfPillMintWhitelistAddresses,\n                leaf\n            )\n        ) revert InvalidMerkleProof();\n\n        pillMintWhitelistedAddresses[msg.sender] = 1;\n\n        emit NewNFTMintedOnPillSale(_tokenIds, msg.sender, msg.value);\n\n        _mint(msg.sender, _tokenIds, 1, """");\n\n        return true;\n    } else {\n        revert UnAuthorizedRequest();\n    }\n}"
"function teamMintingSale() external returns (bool) {\n    if (\n        (block.timestamp >= defaultSaleStartTime + DEFAULT_PILLMINT_SALE) &&\n        (block.timestamp < defaultSaleStartTime + DEFAULT_TEAMMINT_SALE)\n    ) {\n        if (msg.sender != defaultPlatformMintingAddress)\n            revert UnAuthorizedRequest();\n        if (teamMintWhitelistedAddress)\n            revert WhitelistedAddressAlreadyClaimedNFT();\n\n        teamMintWhitelistedAddress = true;\n\n        uint256[] memory newIDs = new uint256[](TEAM_MINT_COUNT);\n        uint256[] memory newAmounts = new uint256[](TEAM_MINT_COUNT);\n\n        uint256 _internalTokenID = _tokenIds;\n\n        for (uint256 i = 0; i < TEAM_MINT_COUNT; i++) {\n            _internalTokenID++;\n\n            newIDs[i] = _internalTokenID;\n            newAmounts[i] = 1;\n        }\n\n        _tokenIds = _internalTokenID;\n\n        emit NewNFTMintedOnTeamSale(newIDs, msg.sender);\n\n        _mintBatch(msg.sender, newIDs, newAmounts, """");\n\n        return true;\n    } else {\n        revert UnAuthorizedRequest();\n    }\n}"
"function lastPublicMintingSale() external payable returns (bool) {\n    if ((block.timestamp >= defaultSaleStartTime + DEFAULT_TEAMMINT_SALE)) {\n        _tokenIds++;\n\n        if (_tokenIds > DEFAULT_MAX_MINTING_SUPPLY)\n            revert MaximumMintSupplyReached();\n\n        if (lastPublicSale[msg.sender] >= LIMIT_IN_PUBLIC_SALE_PER_WALLET)\n            revert MaximumMintLimitReachedByUser();\n\n        if (dutchAuctionLastPrice != msg.value)\n            revert InvalidBuyNFTPrice(dutchAuctionLastPrice, msg.value);\n\n        lastPublicSale[msg.sender] = lastPublicSale[msg.sender] + 1;\n\n        emit NewNFTMintedOnLastPublicSale(_tokenIds, msg.sender, msg.value);\n\n        _mint(msg.sender, _tokenIds, 1, """");\n\n        return true;\n    } else {\n        revert UnAuthorizedRequest();\n    }\n}"
"function firstPublicSaleBatchMint(uint256 tokenCount)\n    external\n    payable\n    returns (bool)\n{\n    if (\n        (block.timestamp >= defaultSaleStartTime) &&\n        (block.timestamp <\n            defaultSaleStartTime + DEFAULT_INITIAL_PUBLIC_SALE)\n    ) {\n        if (tokenCount == 0) revert InvalidTokenCountZero();\n\n        uint256 getPriceOFNFT = getCurrentNFTMintingPrice();\n\n        if ((getPriceOFNFT * tokenCount) != msg.value)\n            revert InvalidBuyNFTPrice(\n                (getPriceOFNFT * tokenCount),\n                msg.value\n            );\n\n        if (\n            firstPublicSale[msg.sender] + tokenCount >\n            LIMIT_IN_PUBLIC_SALE_PER_WALLET\n        ) revert MaximumMintLimitReachedByUser();\n\n        firstPublicSale[msg.sender] =\n            firstPublicSale[msg.sender] +\n            tokenCount;\n\n        uint256[] memory newIDs = new uint256[](tokenCount);\n        uint256[] memory newAmounts = new uint256[](tokenCount);\n\n        if (_tokenIds + tokenCount > DEFAULT_MAX_FIRST_PUBLIC_SUPPLY)\n            revert MaximumPublicMintSupplyReached();\n\n        dutchAuctionLastPrice = getPriceOFNFT;\n\n        for (uint256 i = 0; i < tokenCount; i++) {\n            _tokenIds++;\n\n            newIDs[i] = _tokenIds;\n            newAmounts[i] = 1;\n        }\n\n        emit NewNFTBatchMintedOnFirstPublicSale(\n            newIDs,\n            msg.sender,\n            msg.value\n        );\n\n        _mintBatch(msg.sender, newIDs, newAmounts, """");\n\n        return true;\n    } else {\n        revert UnAuthorizedRequest();\n    }\n}"
"function lastPublicSaleBatchMint(uint256 tokenCount)\n    external\n    payable\n    returns (bool)\n{\n    if ((block.timestamp >= defaultSaleStartTime + DEFAULT_TEAMMINT_SALE)) {\n        if (tokenCount == 0) revert InvalidTokenCountZero();\n\n        if (\n            lastPublicSale[msg.sender] + tokenCount >\n            LIMIT_IN_PUBLIC_SALE_PER_WALLET\n        ) revert MaximumMintLimitReachedByUser();\n\n        if ((dutchAuctionLastPrice * tokenCount) != msg.value)\n            revert InvalidBuyNFTPrice(\n                (dutchAuctionLastPrice * tokenCount),\n                msg.value\n            );\n\n        lastPublicSale[msg.sender] =\n            lastPublicSale[msg.sender] +\n            tokenCount;\n\n        uint256[] memory newIDs = new uint256[](tokenCount);\n        uint256[] memory newAmounts = new uint256[](tokenCount);\n\n        if (_tokenIds + tokenCount > DEFAULT_MAX_MINTING_SUPPLY)\n            revert MaximumMintSupplyReached();\n\n        for (uint256 i = 0; i < tokenCount; i++) {\n            _tokenIds++;\n\n            newIDs[i] = _tokenIds;\n            newAmounts[i] = 1;\n        }\n\n        emit NewNFTBatchMintedOnLastPublicSale(\n            newIDs,\n            msg.sender,\n            msg.value\n        );\n\n        _mintBatch(msg.sender, newIDs, newAmounts, """");\n\n        return true;\n    } else {\n        revert UnAuthorizedRequest();\n    }\n}"
"function sendPaymentForReimbursement() external payable returns (bool) {\n    if (msg.sender != defaultPlatformAddress) revert UnAuthorizedRequest();\n\n    if (msg.value == 0) revert UnAuthorizedRequest();\n\n    emit PaymentSentInContractForReimbursements(msg.value, msg.sender);\n    return true;\n}"
"function withdrawPayment() external returns (bool) {\n    if (msg.sender != defaultPlatformAddress) revert UnAuthorizedRequest();\n\n    uint256 contractBalance = address(this).balance;\n\n    if (contractBalance == 0) revert UnAuthorizedRequest();\n\n    (bool sent, ) = defaultPlatformAddress.call{value: contractBalance}("""");\n\n    if (!sent) revert TransactionFailed();\n\n    emit WithdrawnPayment(contractBalance, msg.sender);\n    return true;\n}"
"function reimbursementAirdrop(\n    address[] memory addresses,\n    uint256[] memory values\n) external returns (bool) {\n    if (\n        (block.timestamp >= defaultSaleStartTime) &&\n        (block.timestamp <\n            defaultSaleStartTime + DEFAULT_INITIAL_PUBLIC_SALE)\n    ) revert CannotClaimReimbursementInPublicMint();\n\n    if (msg.sender != defaultPlatformAddress) revert UnAuthorizedRequest();\n\n    if (addresses.length != values.length) revert UnAuthorizedRequest();\n\n    for (uint256 i = 0; i < addresses.length; i++) {\n        (bool sent, ) = addresses[i].call{value: values[i]}("""");\n        if (!sent) revert AirdropTransactionFailed(addresses[i], values[i]);\n    }\n\n    emit ReimbursementClaimedOfPublicSale(addresses, values);\n    return true;\n}"
